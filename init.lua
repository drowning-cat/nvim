if vim.fn.has("nvim-0.12") == 0 then
  return vim.notify("Install Neovim 0.12+", vim.log.levels.ERROR)
end

vim.g.mapleader = " "

vim.o.number = true
vim.o.relativenumber = true

vim.o.signcolumn = "yes"

vim.o.updatetime = 250
vim.o.timeoutlen = 300

vim.o.splitbelow = true
vim.o.splitright = true
vim.o.tabclose = "uselast"

vim.o.confirm = true

vim.o.breakindent = true
-- vim.o.wrap = false

vim.o.expandtab = true
vim.o.tabstop = 4
vim.o.shiftwidth = 2
vim.o.softtabstop = -1

vim.o.foldmethod = "indent"
vim.o.foldtext = ""
vim.o.foldlevel = 99
vim.o.foldlevelstart = 99
vim.o.foldnestmax = 10

vim.o.undofile = true
vim.o.undolevels = 10000

vim.o.ignorecase = true
vim.o.smartcase = true

vim.opt.iskeyword:append("-")

vim.o.list = true
vim.o.listchars = "tab:▷ ,trail:·,nbsp:○"

vim.o.spell = true
vim.o.spelllang = "en_us,ru"
vim.o.spelloptions = "camel"

vim.opt.backup = true
vim.opt.backupdir = vim.fn.stdpath("state") .. "/backup"

-- Custom opts

vim.g.session_center = false

vim.g.root_ignore = { "~", "/" }
vim.g.root_markers = {
  ".git",
  "Makefile",
  "package.json",
}

vim.g.ts_install = {
  "bash",
  "c",
  "css",
  "diff",
  "go",
  "html",
  "javascript",
  "json",
  "lua",
  "python",
  "toml",
  "tsx",
  "typescript",
  "yaml",
  "zig",
}

vim.g.mason_install = {
  "delve",
  "deno",
  "gopls",
  "lua-language-server",
  "prettier",
  "shfmt",
  "stylua",
}

vim.g.lsp_enable = {
  "gopls",
  "lua_ls",
}

vim.g.format_on_save = true

local buf_name = function(buf)
  return vim.api.nvim_buf_get_name(buf or 0)
end

---@type table<string, fun(line1:integer,line2:integer):FormatBufOpts|FormatBufOpts[]>
local formatters = {
  stylua = function()
    return { cmd = { "stylua", "--indent-type=Spaces", "--indent-width=2", "--stdin-filepath", buf_name(), "-" } }
  end,
  prettier = function()
    return { cmd = { "prettier", "--stdin-filepath", buf_name() } }
  end,
  shfmt = function()
    return { cmd = { "shfmt", "--indent=2", "-" } }
  end,
}

vim.g.formatconf = {
  ["javascript"] = formatters["prettier"],
  ["javascriptreact"] = formatters["prettier"],
  ["json"] = formatters["prettier"],
  ["jsonc"] = formatters["prettier"],
  ["lua"] = formatters["stylua"],
  ["markdown"] = formatters["prettier"],
  ["scss"] = formatters["prettier"],
  ["sh"] = formatters["shfmt"],
  ["typescript"] = formatters["prettier"],
  ["typescriptreact"] = formatters["prettier"],
  ["yaml"] = formatters["prettier"],
}

-- Core

require("vim._extui").enable({
  msg = {
    target = "cmd",
    timeout = 4000,
  },
})

-- -- Commands

vim.api.nvim_create_user_command("Mkdir", function(o)
  local path = vim.fn.expand(o.args ~= "" and o.args or "%:p:h")
  vim.fn.mkdir(path, "p")
end, { nargs = "?", complete = "dir" })

vim.api.nvim_create_user_command("PackUpdate", function()
  vim.pack.update()
end, {})

-- -- Mappings

-- vim.keymap.set("x", "p", "P")
-- vim.keymap.set("x", "P", "p")

-- vim.keymap.set("n", "<C-h>", "<C-w>h", { desc = "Jump left" })
-- vim.keymap.set("n", "<C-j>", "<C-w>j", { desc = "Jump down" })
-- vim.keymap.set("n", "<C-k>", "<C-w>k", { desc = "Jump top" })
-- vim.keymap.set("n", "<C-l>", "<C-w>l", { desc = "Jump right" })

vim.keymap.set({ "i", "c" }, "<C-S-h>", "<Left>")
vim.keymap.set({ "i", "c" }, "<C-S-j>", "<Down>")
vim.keymap.set({ "i", "c" }, "<C-S-k>", "<Up>")
vim.keymap.set({ "i", "c" }, "<C-S-l>", "<Right>")

vim.keymap.set("n", "<Esc>", "<Cmd>nohlsearch<Enter>")

vim.keymap.set("o", "C", "gc", { remap = true, desc = "Comment textobject" })

vim.keymap.set("n", "gA", "<Cmd>tabnew|b#<Enter>", { desc = "Add tab" })
vim.keymap.set("n", "gC", "<Cmd>tabclose<Enter>", { desc = "Close tab" })

vim.keymap.set("n", "<C-w>Q", "<Cmd>qall<Enter>", { desc = "Quit" })

-- -- -- Restart

local tmp_session = "Restart.vim"
function _G.after_restart(orig_session)
  -- NOTE: See `MiniSession`
  vim.g.after_restart = true
  vim.cmd.source(tmp_session)
  vim.fs.rm(tmp_session, { force = true })
  vim.v.this_session = orig_session
end
vim.keymap.set("n", "<Leader>R", function()
  local this_session = vim.v.this_session
  vim.cmd.write({ mods = { silent = true, emsg_silent = true } })
  vim.cmd.mksession({ tmp_session, bang = true })
  vim.cmd.restart(string.format("lua _G.after_restart('%s')", this_session))
end, { desc = "Restart" })

-- -- -- Copy to clipboard

vim.keymap.set("n", "gy", function()
  local copy = vim.fn.getreg('"')
  if copy == "" then
    return
  end
  vim.fn.setreg("+", copy)
  local msg = ""
  local _, ln = string.gsub(copy, "\n", "")
  if ln > 0 then
    msg = string.format('%s %s yanked into "+', ln, ln > 1 and "lines" or "line")
  else
    local ch = vim.fn.strdisplaywidth(copy)
    msg = string.format('%s %s yanked into "+', ch, ch > 1 and "chars" or "char")
  end
  vim.api.nvim_echo({ { msg } }, false, {})
end, { desc = "Yank last into clipboard" })

-- -- -- Quickfix toggle

local qf_height = { l = 10, c = 10 }
local toggle_list = function(nr)
  local mods = { split = "botright" }
  local type, win
  if nr then
    type, win = "l", vim.fn.getloclist(nr, { winid = true }).winid
  else
    type, win = "c", vim.fn.getqflist({ winid = true }).winid
  end
  if win > 0 then
    qf_height[type] = vim.api.nvim_win_get_height(win)
    vim.cmd({ cmd = type .. "close", mods = mods })
  else
    vim.cmd({ cmd = type .. "open" })
    vim.api.nvim_win_set_height(0, qf_height[type])
  end
end
-- stylua: ignore
vim.keymap.set("n", "<Leader>l", function() toggle_list() end, { desc = "Toggle qf" })
-- stylua: ignore
vim.keymap.set("n", "<Leader>L", function() toggle_list(0) end, { desc = "Toggle loc" })

-- -- Autocmds

vim.api.nvim_create_autocmd("TextYankPost", {
  desc = "Highlight yanking text",
  group = vim.api.nvim_create_augroup("yank_highlight", { clear = true }),
  callback = function()
    vim.hl.on_yank()
  end,
})

-- -- Detect root
-- -- NOTE: See `MiniSessions`

vim.g.cwd_glob = vim.fn.getcwd()
vim.g.cwd_auto = vim.fn.getcwd()

vim.api.nvim_create_autocmd("DirChangedPre", {
  group = vim.api.nvim_create_augroup("find_root", { clear = true }),
  callback = function(e)
    if e.match == "global" then
      vim.g.cwd_glob = e.file
    end
    if e.match == "auto" then
      vim.g.cwd_auto = e.file
    end
  end,
})

local path_contain = function(path, ignore_list)
  return vim.iter(ignore_list):any(function(ignore)
    return vim.fs.normalize(path) == vim.fs.normalize(ignore)
  end)
end
function _G.find_root(source)
  source = source or vim.g.cwd_glob
  local root = vim.fs.root(source, vim.g.root_markers or {})
  if not root or path_contain(root, vim.g.root_ignore or {}) then
    return nil
  end
  return root
end

-- Plugins

vim.api.nvim_create_autocmd("PackChanged", {
  pattern = "blink.cmp",
  desc = "Run `:BlinkCmp build` after pack update",
  group = vim.api.nvim_create_augroup("blink_update", { clear = true }),
  callback = function(e)
    if e.data.kind == "install" or e.data.kind == "update" then
      vim.cmd.packadd({ args = { e.data.spec.name }, bang = false })
      vim.defer_fn(function()
        require("blink.cmp.fuzzy.build").build()
      end, 200)
    end
  end,
})

vim.api.nvim_create_autocmd("PackChanged", {
  pattern = "nvim-treesitter",
  desc = "Run `:TSUpdate` after pack update",
  group = vim.api.nvim_create_augroup("ts_update", { clear = true }),
  callback = function(e)
    if e.data.kind == "update" then
      require("nvim-treesitter").update()
    end
  end,
})

vim.pack.add({
  { src = "https://github.com/folke/tokyonight.nvim" },
  { src = "https://github.com/Saghen/blink.cmp", version = "main" },
  { src = "https://github.com/MeanderingProgrammer/render-markdown.nvim" },
  { src = "https://github.com/nvim-mini/mini.nvim", version = "main" },
  { src = "https://github.com/nvim-treesitter/nvim-treesitter", version = "main" },
  { src = "https://github.com/nvim-treesitter/nvim-treesitter-textobjects", version = "main" },
  { src = "https://github.com/Wansmer/treesj" },
  { src = "https://github.com/mason-org/mason.nvim" },
  { src = "https://github.com/neovim/nvim-lspconfig" },
  { src = "https://github.com/mfussenegger/nvim-dap" },
  { src = "https://github.com/igorlfs/nvim-dap-view" },
  { src = "https://github.com/theHamsta/nvim-dap-virtual-text" },
})

-- -- Colorscheme

vim.api.nvim_create_autocmd("ColorScheme", {
  pattern = "*",
  desc = "Set up custom highlights",
  group = vim.api.nvim_create_augroup("custom_highlights", { clear = true }),
  callback = function()
    local perf_bg = vim.api.nvim_get_hl(0, { name = "Indentifier", link = false }).fg
    vim.api.nvim_set_hl(0, "HipatternsPerf", { bold = true, fg = "black", bg = perf_bg })
    vim.api.nvim_set_hl(0, "LspProgress", { default = true, link = "Comment" })
  end,
})

require("tokyonight").setup({
  on_highlights = function(hl, c)
    -- hl.DiagnosticUnnecessary = {}
    hl.LspProgress = { fg = c.comment }
  end,
})

-- -- -- Load colorscheme

vim.api.nvim_create_autocmd("ColorScheme", {
  desc = "Save the colorscheme in shada-persistent variables",
  group = vim.api.nvim_create_augroup("save_colors", { clear = true }),
  callback = function()
    vim.g.COLORS_NAME = vim.g.colors_name
    vim.g.COLORS_BG = vim.o.background
  end,
})

local set_colorscheme = function(bg, name)
  return pcall(function()
    vim.o.background = bg
    vim.cmd.colorscheme(name)
  end)
end
vim.cmd.rshada()
if not set_colorscheme(vim.g.COLORS_BG, vim.g.COLORS_NAME) then
  set_colorscheme("dark", "default")
end

-- -- Completion

require("blink.cmp").setup({
  keymap = {
    ["<C-n>"] = { "show_and_insert", "select_next" },
    ["<C-p>"] = { "show_and_insert", "select_prev" },
    ["<C-j>"] = { "select_and_accept" },
  },
  cmdline = {
    keymap = { ["<Right>"] = false, ["<Left>"] = false },
    completion = {
      menu = { auto_show = true },
      list = { selection = { preselect = false } },
    },
  },
})

vim.keymap.set("i", "<C-x><C-o>", function()
  require("blink.cmp").show()
  require("blink.cmp").show_documentation()
  require("blink.cmp").hide_documentation()
end, { desc = "Show completion" })

-- -- Markdown

require("render-markdown").setup({
  checkbox = { enabled = false },
  code = { sign = false, width = "full" },
  heading = { icons = {} },
})

-- -- Mini

local MiniAi = require("mini.ai")
MiniAi.setup({
  mappings = {
    around_next = "an",
    inside_next = "in",
    around_last = "",
    inside_last = "",
    goto_left = "g[",
    goto_right = "g]",
  },
  custom_textobjects = {
    B = MiniAi.gen_spec.treesitter({ a = "@block.outer", i = "@block.inner" }),
    C = MiniAi.gen_spec.treesitter({ a = "@class.outer", i = "@class.inner" }),
    F = MiniAi.gen_spec.treesitter({ a = "@function.outer", i = "@function.inner" }),
    I = MiniAi.gen_spec.treesitter({ a = "@conditional.outer", i = "@conditional.inner" }),
    L = MiniAi.gen_spec.treesitter({ a = "@loop.outer", i = "@loop.inner" }),
    O = MiniAi.gen_spec.treesitter({
      a = { "@block.outer", "@conditional.outer", "@loop.outer" },
      i = { "@block.inner", "@conditional.inner", "@loop.inner" },
    }),
    a = MiniAi.gen_spec.argument({ separator = ",%s*" }),
    e = function(ai_type, id, opts)
      if ai_type == "a" then
        return {
          {
            -- pattern, [^_]pattern_*
            "%f[%a_/\\%-]%l+%d*[_/\\%-]*",
            "%f[%w_/\\%-]%d+[_/\\%-]*",
            "%f[%u_/\\%-]%u%f[%A]%d*[_/\\%-]*",
            "%f[%u_/\\%-]%u%l+%d*[_/\\%-]*",
            "%f[%u_/\\%-]%u%u+%d*[_/\\%-]*",
            -- __pattern
            "%f[_/\\%-][_/\\%-]+%l+%d*",
            "%f[_/\\%-][_/\\%-]+%d+",
            "%f[_/\\%-][_/\\%-]+%u%f[%A]%d*",
            "%f[_/\\%-][_/\\%-]+%u%l+%d*",
            "%f[_/\\%-][_/\\%-]+%u%u+%d*",
          },
        }
      end
      if ai_type == "i" then
        local reg = MiniAi.find_textobject("a", id, opts)
        if reg then
          local line = vim.fn.getline(reg.from.line)
          local _, s = line:find("^[_/\\%-]*.", reg.from.col)
          local e = line:sub(1, reg.to.col):find(".[_/\\%-]*$")
          return vim.tbl_deep_extend("force", reg, { from = { col = s }, to = { col = e } })
        end
      end
    end,
    g = function()
      local from = { line = 1, col = 1 }
      local to = {
        line = vim.fn.line("$"),
        col = math.max(vim.fn.getline("$"):len(), 1),
      }
      return { from = from, to = to }
    end,
    t = { "<([%p%w]-)%f[^<%w][^<>]->.-</%1>", "^<.->().*()</[^/]->$" },
  },
})
vim.keymap.set("n", ",", function()
  local char = vim.fn.getcharstr()
  local id = string.lower(char)
  local ai_type = string.match(id, "[ea]") and "i" or "a"
  local search_method = char == id and "next" or "prev"
  MiniAi.move_cursor("left", ai_type, id, { search_method = search_method, n_times = vim.v.count1 })
end)

local MiniAlign = require("mini.align")
MiniAlign.setup({
  mappings = {
    start = "",
    start_with_preview = "g|",
  },
  modifiers = {
    k = function(_, opts)
      local cycle_rev = { none = "right", right = "center", center = "left", left = "right" }
      opts.justify_side = cycle_rev[opts.justify_side] or "right"
    end,
    j = function(_, opts)
      local cycle = { none = "left", left = "center", center = "right", right = "left" }
      opts.justify_side = cycle[opts.justify_side] or "left"
    end,
    n = function(_, opts)
      opts.justify_side = "none"
    end,
  },
})

local MiniSurround = require("mini.surround")
local surround_sel = function()
  local mark1 = vim.api.nvim_buf_get_mark(0, vim.v.operator == ":" and "<" or "[")
  local mark2 = vim.api.nvim_buf_get_mark(0, vim.v.operator == ":" and ">" or "]")
  local range = { mark1[1], mark1[2], mark2[1], mark2[2] }
  range[4] = math.min(range[4], #vim.fn.getline(range[3]) - 1)
  local text_lines = vim.api.nvim_buf_get_text(0, range[1] - 1, range[2], range[3] - 1, range[4] + 1, {})
  return text_lines, range
end
MiniSurround.setup({
  mappings = {
    find = "",
    find_left = "",
    highlight = "",
    update_n_lines = "",
    suffix_last = "",
    suffix_next = "",
  },
  custom_surroundings = {
    l = nil, -- Reserved for `log`
    L = {
      output = function()
        if not vim.b.minisurround_config.custom_surroundings.l then
          return
        end
        local sel_lines, sel_range = surround_sel()
        local indent_str = string.match(vim.fn.getline(sel_range[1]), "^%s*")
        sel_lines[1] = string.gsub(sel_lines[1], "^%s*", indent_str)
        vim.api.nvim_buf_set_lines(0, sel_range[3], sel_range[3], true, sel_lines)
        vim.api.nvim_win_set_cursor(0, { sel_range[3] + 1, #indent_str })
        vim.cmd.norm("v")
        vim.api.nvim_win_set_cursor(0, { sel_range[3] + #sel_lines, sel_range[4] })
        vim.cmd.norm("sal")
      end,
    },
  },
})

local MiniClue = require("mini.clue")
local resize_prefix = "<C-w>R"
vim.keymap.set("n", resize_prefix .. "q", "<nop>", { desc = "Quit" })
vim.keymap.set("n", resize_prefix .. "H", "<C-w>h", { remap = true, desc = "Move left" })
vim.keymap.set("n", resize_prefix .. "J", "<C-w>j", { remap = true, desc = "Move down" })
vim.keymap.set("n", resize_prefix .. "K", "<C-w>k", { remap = true, desc = "Move up" })
vim.keymap.set("n", resize_prefix .. "L", "<C-w>l", { remap = true, desc = "Move right" })
local resize = function(dir)
  local step = { h = 4, v = 2 }
  if dir == "h" then
    vim.fn.win_move_separator(vim.fn.winnr("h"), -step.h)
  elseif dir == "l" then
    vim.fn.win_move_separator(vim.fn.winnr("h"), step.h)
  elseif dir == "k" then
    vim.fn.win_move_statusline(vim.fn.winnr("k"), -step.v)
  elseif dir == "j" then
    vim.fn.win_move_statusline(vim.fn.winnr("k"), step.v)
  end
end
-- stylua: ignore start
vim.keymap.set("n", resize_prefix .. "h", function() resize("h") end, { desc = "Resize left" })
vim.keymap.set("n", resize_prefix .. "j", function() resize("j") end, { desc = "Resize down" })
vim.keymap.set("n", resize_prefix .. "k", function() resize("k") end, { desc = "Resize up" })
vim.keymap.set("n", resize_prefix .. "l", function() resize("l") end, { desc = "Resize right" })
-- stylua: ignore end
local gen_clues_resize = function()
  return {
    { mode = "n", keys = resize_prefix .. "q" },
    { mode = "n", keys = resize_prefix .. "H", postkeys = resize_prefix },
    { mode = "n", keys = resize_prefix .. "J", postkeys = resize_prefix },
    { mode = "n", keys = resize_prefix .. "K", postkeys = resize_prefix },
    { mode = "n", keys = resize_prefix .. "L", postkeys = resize_prefix },
    { mode = "n", keys = resize_prefix .. "h", postkeys = resize_prefix },
    { mode = "n", keys = resize_prefix .. "j", postkeys = resize_prefix },
    { mode = "n", keys = resize_prefix .. "k", postkeys = resize_prefix },
    { mode = "n", keys = resize_prefix .. "l", postkeys = resize_prefix },
  }
end
MiniClue.setup({
  triggers = {
    { mode = "n", keys = resize_prefix },
    { mode = "n", keys = "[" },
    { mode = "n", keys = "]" },
    { mode = "n", keys = "<C-w>" },
    { mode = "i", keys = "<C-x>" },
    { mode = { "n", "x" }, keys = "<Leader>" },
    { mode = { "n", "x" }, keys = "'" },
    { mode = { "n", "x" }, keys = "`" },
    { mode = { "n", "x" }, keys = '"' },
    { mode = { "n", "x" }, keys = "g" },
    { mode = { "n", "x" }, keys = "z" },
    { mode = { "i", "c" }, keys = "<C-r>" },
  },
  clues = {
    gen_clues_resize(),
    MiniClue.gen_clues.square_brackets(),
    MiniClue.gen_clues.builtin_completion(),
    MiniClue.gen_clues.marks(),
    MiniClue.gen_clues.registers(),
    MiniClue.gen_clues.windows(),
    MiniClue.gen_clues.g(),
    MiniClue.gen_clues.z(),
  },
})

local MiniDiff = require("mini.diff")
MiniDiff.setup({
  mappings = {
    textobject = "ih",
    -- apply = "gh",
    -- reset = "gH",
    goto_prev = "[h",
    goto_next = "]h",
  },
})
local hunk_action = function(mode)
  return function()
    return MiniDiff.operator(mode) .. MiniDiff.config.mappings.textobject
  end
end
vim.keymap.set("n", "gh", hunk_action("apply"), { expr = true, remap = true, desc = "Apply hunk" })
vim.keymap.set("n", "gH", hunk_action("reset"), { expr = true, remap = true, desc = "Reset hunk" })
-- stylua: ignore
vim.keymap.set("n", "<Leader>go", function() MiniDiff.toggle_overlay() end, { desc = "Toggle overlay" })
vim.keymap.set("n", "<Leader>gb", function()
  local git_wins = vim
    .iter(vim.api.nvim_list_wins())
    :filter(function(win)
      local buf = vim.api.nvim_win_get_buf(win)
      return vim.bo[buf].ft == "git"
    end)
    :totable()
  if vim.tbl_isempty(git_wins) then
    vim.cmd([[vert above Git blame -- %]])
  else
    for _, win in ipairs(git_wins) do
      vim.api.nvim_win_close(win, false)
    end
  end
end, { desc = "Toggle blame" })

local MiniFiles = require("mini.files")
MiniFiles.setup({
  windows = {
    width_preview = 100,
  },
})
local minifiles_au = vim.api.nvim_create_augroup("minifiles", { clear = true })
vim.api.nvim_create_autocmd("VimResized", {
  group = minifiles_au,
  callback = function()
    local width_focus = MiniFiles.config.windows.width_focus
    local width_preview = MiniFiles.config.windows.width_preview
    local preview_width = math.min(vim.o.columns - width_focus - 4, width_preview)
    MiniFiles.refresh({ windows = { width_preview = preview_width } })
  end,
})
local set_bookmark = function(id, path, opts)
  MiniFiles.set_bookmark(id, function()
    path = vim.is_callable(path) and path() or path
    if type(path) ~= "string" then
      return path
    end
    path = vim.fs.abspath(path)
    local stat = vim.uv.fs_stat(path)
    if not stat then
      return path
    end
    if stat.type == "directory" then
      return path
    else
      vim.schedule(function()
        if vim.bo.ft == "minifiles" then
          local buf = 0
          local win = 0
          for line = 1, vim.api.nvim_buf_line_count(buf) do
            local entry = MiniFiles.get_fs_entry(buf, line)
            if entry.path == path then
              vim.api.nvim_win_set_cursor(win, { line, 0 })
            end
          end
        end
      end)
      return vim.fs.dirname(path)
    end
  end, opts)
end
local files_main = nil
local files_open = MiniFiles.open
MiniFiles.open = function(...)
  if vim.bo.ft ~= "minifiles" then
    files_main = vim.api.nvim_get_current_buf()
  end
  return files_open(...)
end
vim.api.nvim_create_autocmd("User", {
  pattern = "MiniFilesExplorerOpen",
  group = minifiles_au,
  callback = function()
    if files_main then
      set_bookmark("%", vim.api.nvim_buf_get_name(files_main), { desc = "Entry file" })
    end
    set_bookmark("@", vim.fn.getcwd, { desc = "Cwd" })
    set_bookmark("n", vim.fn.stdpath("config") .. "/init.lua", { desc = "Config" })
    set_bookmark("p", vim.fn.stdpath("data") .. "/site/pack/core/opt", { desc = "Plugins" })
  end,
})
MiniFiles.actions = {
  toggle_preview = function()
    local preview = MiniFiles.config.windows.preview
    local preview_next = not preview
    MiniFiles.config.windows.preview = preview_next
    MiniFiles.refresh({ windows = { preview = preview_next } })
    if preview then
      local branch = MiniFiles.get_explorer_state().branch
      table.remove(branch)
      MiniFiles.set_branch(branch)
    end
  end,
  search_files = function()
    local MiniPick = require("mini.pick")
    local entry = MiniFiles.get_fs_entry()
    if not entry then
      return
    end
    local parent = vim.fn.fnamemodify(entry.path, ":h")
    MiniPick.registry.files(nil, { source = { cwd = parent } })
  end,
  search_grep = function()
    local MiniPick = require("mini.pick")
    local entry = MiniFiles.get_fs_entry()
    if not entry then
      return
    end
    local parent = vim.fn.fnamemodify(entry.path, ":h")
    MiniPick.registry.grep({ pattern = "." }, { source = { cwd = parent } })
  end,
}
vim.api.nvim_create_autocmd("User", {
  pattern = "MiniFilesBufferCreate",
  group = minifiles_au,
  callback = function(e)
    local buf_map = function(mode, lhs, rhs, opts)
      opts = vim.tbl_extend("keep", opts or {}, { buffer = e.data.buf_id })
      vim.keymap.set(mode, lhs, rhs, opts)
    end
    -- stylua: ignore start
    buf_map("n", "<M-p>", function() MiniFiles.actions.toggle_preview() end, { desc = "Toggle preview" })
    buf_map("n", "<Leader>sg", function() MiniFiles.actions.search_grep() end, { desc = "Search grep" })
    buf_map("n", "<Leader>sf", function() MiniFiles.actions.search_files() end, { desc = "Search files" })
    -- stylua: ignore end
  end,
})
vim.api.nvim_create_autocmd("User", {
  pattern = "MiniFilesWindowUpdate",
  group = minifiles_au,
  callback = function(e)
    local win = e.data.win_id
    vim.wo[win].number = true
    vim.wo[win].relativenumber = true
  end,
})
local minifiles_open_buf = function(buf)
  buf = buf or 0
  MiniFiles.open(vim.bo[buf].buftype == "" and vim.api.nvim_buf_get_name(buf) or nil, true)
end
-- stylua: ignore start
vim.keymap.set("n", "<Leader>F", function() MiniFiles.open() end, { desc = "Open files" })
vim.keymap.set("n", "<Leader>.F", function() minifiles_open_buf() end, { desc = "Open files (current buf)" })
vim.keymap.set("n", "<Leader>@F", function() MiniFiles.open(vim.fn.getcwd()) end, { desc = "Open files (cwd)" })
vim.keymap.set("n", "<Leader>~F", function() MiniFiles.open("~") end, { desc = "Open files (system home)" })
-- stylua: ignore end

local MiniGit = require("mini.git")
MiniGit.setup()
vim.cmd.cnoreabbrev("G", "Git")
vim.api.nvim_create_autocmd("User", {
  pattern = "MiniGitCommandSplit",
  desc = "Enhance `Git blame`: colorize buffer and set width for vertical split",
  group = vim.api.nvim_create_augroup("mini_gitblame", { clear = true }),
  callback = function(e)
    if e.data.git_subcommand ~= "blame" then
      return
    end
    local win_src = e.data.win_source
    local buf = e.buf
    local win = e.data.win_stdout
    vim.bo[buf].modifiable = false
    vim.wo[win].wrap = false
    vim.wo[win].cursorline = true
    vim.fn.winrestview({ topline = vim.fn.line("w0", win_src) })
    vim.api.nvim_win_set_cursor(0, { vim.fn.line(".", win_src), 0 })
    vim.wo[win].scrollbind, vim.wo[win_src].scrollbind = true, true
    vim.wo[win].cursorbind, vim.wo[win_src].cursorbind = true, true
    if string.match(e.data.cmd_input.mods, "vertical") then
      local lines = vim.api.nvim_buf_get_lines(0, 1, -1, false)
      local width = vim.iter(lines):fold(-1, function(acc, ln)
        local stat = string.match(ln, "^[%w%p]+ %b()")
        return math.max(acc, vim.fn.strwidth(stat))
      end)
      width = width + vim.fn.getwininfo(win)[1].textoff
      vim.api.nvim_win_set_width(win, width)
    end
    local leftmost = [[^.\{-}\zs]]
    -- stylua: ignore start
    --[[ ^hash  ]] vim.fn.matchadd("Tag", [[^^\w\+]])
    --[[ hash   ]] vim.fn.matchadd("Identifier", [[^\w\+]])
    --[[ author ]] vim.fn.matchadd("String", leftmost .. [[(\zs.\{-} \ze\d\{4}-]])
    --[[ date   ]] vim.fn.matchadd("Comment", leftmost .. [[[0-9-]\{10} [0-9:]\{8} [+-]\d\+]])
  end,
})
vim.cmd.cnoreabbrev("Gc", "Git commit")
vim.cmd.cnoreabbrev("Gcm", "Git commit --message")
vim.cmd.cnoreabbrev("Gca", "Git commit --amend")
vim.cmd.cnoreabbrev("Gcan", "Git commit --amend --no-edit")

local MiniHipatterns = require("mini.hipatterns")
local hi_todo = function(words, hl_name)
  local pattern = vim
    .iter(words)
    :map(function(word)
      return {
        "() ?" .. word .. "%(.-%)[: ]()",
        "() ?" .. word .. "[: ]()",
      }
    end)
    :flatten()
    :totable()
  return {
    pattern = pattern,
    group = function(buf, _, data)
      local parser = vim.treesitter.get_parser(buf, nil, { error = false })
      if not parser then
        return hl_name
      end
      local range4 = {
        data.line - 1,
        data.from_col - 1,
        data.line - 1,
        data.to_col - 1,
      }
      parser:parse(range4)
      local node = parser:named_node_for_range(range4)
      if node and node:type() == "comment_content" then
        return hl_name
      end
    end,
  }
end
local tw_store = {
  hl = {},
  -- stylua: ignore
  cl = {
    slate={[50]="f8fafc",[100]="f1f5f9",[200]="e2e8f0",[300]="cbd5e1",[400]="94a3b8",
    [500]="64748b",[600]="475569",[700]="334155",[800]="1e293b",[900]="0f172a",[950]="020617"},
    gray={[50]="f9fafb",[100]="f3f4f6",[200]="e5e7eb",[300]="d1d5db",[400]="9ca3af",
    [500]="6b7280",[600]="4b5563",[700]="374151",[800]="1f2937",[900]="111827",[950]="030712"},
    zinc={[50]="fafafa",[100]="f4f4f5",[200]="e4e4e7",[300]="d4d4d8",[400]="a1a1aa",
    [500]="71717a",[600]="52525b",[700]="3f3f46",[800]="27272a",[900]="18181b",[950]="09090B"},
    neutral={[50]="fafafa",[100]="f5f5f5",[200]="e5e5e5",[300]="d4d4d4",[400]="a3a3a3",
    [500]="737373",[600]="525252",[700]="404040",[800]="262626",[900]="171717",[950]="0a0a0a"},
    stone={[50]="fafaf9",[100]="f5f5f4",[200]="e7e5e4",[300]="d6d3d1",[400]="a8a29e",
    [500]="78716c",[600]="57534e",[700]="44403c",[800]="292524",[900]="1c1917",[950]="0a0a0a"},
    red={[50]="fef2f2",[100]="fee2e2",[200]="fecaca",[300]="fca5a5",[400]="f87171",
    [500]="ef4444",[600]="dc2626",[700]="b91c1c",[800]="991b1b",[900]="7f1d1d",[950]="450a0a"},
    orange={[50]="fff7ed",[100]="ffedd5",[200]="fed7aa",[300]="fdba74",[400]="fb923c",
    [500]="f97316",[600]="ea580c",[700]="c2410c",[800]="9a3412",[900]="7c2d12",[950]="431407"},
    amber={[50]="fffbeb",[100]="fef3c7",[200]="fde68a",[300]="fcd34d",[400]="fbbf24",
    [500]="f59e0b",[600]="d97706",[700]="b45309",[800]="92400e",[900]="78350f",[950]="451a03"},
    yellow={[50]="fefce8",[100]="fef9c3",[200]="fef08a",[300]="fde047",[400]="facc15",
    [500]="eab308",[600]="ca8a04",[700]="a16207",[800]="854d0e",[900]="713f12",[950]="422006"},
    lime={[50]="f7fee7",[100]="ecfccb",[200]="d9f99d",[300]="bef264",[400]="a3e635",
    [500]="84cc16",[600]="65a30d",[700]="4d7c0f",[800]="3f6212",[900]="365314",[950]="1a2e05"},
    green={[50]="f0fdf4",[100]="dcfce7",[200]="bbf7d0",[300]="86efac",[400]="4ade80",
    [500]="22c55e",[600]="16a34a",[700]="15803d",[800]="166534",[900]="14532d",[950]="052e16"},
    emerald={[50]="ecfdf5",[100]="d1fae5",[200]="a7f3d0",[300]="6ee7b7",[400]="34d399",
    [500]="10b981",[600]="059669",[700]="047857",[800]="065f46",[900]="064e3b",[950]="022c22"},
    teal={[50]="f0fdfa",[100]="ccfbf1",[200]="99f6e4",[300]="5eead4",[400]="2dd4bf",
    [500]="14b8a6",[600]="0d9488",[700]="0f766e",[800]="115e59",[900]="134e4a",[950]="042f2e"},
    cyan={[50]="ecfeff",[100]="cffafe",[200]="a5f3fc",[300]="67e8f9",[400]="22d3ee",
    [500]="06b6d4",[600]="0891b2",[700]="0e7490",[800]="155e75",[900]="164e63",[950]="083344"},
    sky={[50]="f0f9ff",[100]="e0f2fe",[200]="bae6fd",[300]="7dd3fc",[400]="38bdf8",
    [500]="0ea5e9",[600]="0284c7",[700]="0369a1",[800]="075985",[900]="0c4a6e",[950]="082f49"},
    blue={[50]="eff6ff",[100]="dbeafe",[200]="bfdbfe",[300]="93c5fd",[400]="60a5fa",
    [500]="3b82f6",[600]="2563eb",[700]="1d4ed8",[800]="1e40af",[900]="1e3a8a",[950]="172554"},
    indigo={[50]="eef2ff",[100]="e0e7ff",[200]="c7d2fe",[300]="a5b4fc",[400]="818cf8",
    [500]="6366f1",[600]="4f46e5",[700]="4338ca",[800]="3730a3",[900]="312e81",[950]="1e1b4b"},
    violet={[50]="f5f3ff",[100]="ede9fe",[200]="ddd6fe",[300]="c4b5fd",[400]="a78bfa",
    [500]="8b5cf6",[600]="7c3aed",[700]="6d28d9",[800]="5b21b6",[900]="4c1d95",[950]="2e1065"},
    purple={[50]="faf5ff",[100]="f3e8ff",[200]="e9d5ff",[300]="d8b4fe",[400]="c084fc",
    [500]="a855f7",[600]="9333ea",[700]="7e22ce",[800]="6b21a8",[900]="581c87",[950]="3b0764"},
    fuchsia={[50]="fdf4ff",[100]="fae8ff",[200]="f5d0fe",[300]="f0abfc",[400]="e879f9",
    [500]="d946ef",[600]="c026d3",[700]="a21caf",[800]="86198f",[900]="701a75",[950]="4a044e"},
    pink={[50]="fdf2f8",[100]="fce7f3",[200]="fbcfe8",[300]="f9a8d4",[400]="f472b6",
    [500]="ec4899",[600]="db2777",[700]="be185d",[800]="9d174d",[900]="831843",[950]="500724"},
    rose={[50]="fff1f2",[100]="ffe4e6",[200]="fecdd3",[300]="fda4af",[400]="fb7185",
    [500]="f43f5e",[600]="e11d48",[700]="be123c",[800]="9f1239",[900]="881337",[950]="4c0519"},
  },
}
vim.api.nvim_create_autocmd("ColorScheme", {
  desc = "Reset tailwind hl-store on colorscheme change",
  group = vim.api.nvim_create_augroup("reset_tailwind_hl", { clear = true }),
  callback = function()
    tw_store.hl = {}
  end,
})
MiniHipatterns.setup({
  highlighters = {
    fix = hi_todo({ "FIX", "FIXME", "BUG" }, "MiniHipatternsFixme"),
    note = hi_todo({ "NOTE" }, "MiniHipatternsNote"),
    todo = hi_todo({ "TODO", "FEAT" }, "MiniHipatternsTodo"),
    hack = hi_todo({ "WARN", "WARNING", "HACK" }, "MiniHipatternsHack"),
    perf = hi_todo({ "PERF" }, "HipatternsPerf"),
    hex_color = MiniHipatterns.gen_highlighter.hex_color(),
    hex_color_short = {
      pattern = "()#%x%x%x()%f[^%x%w]",
      group = function(_, _, data)
        local match = data.full_match
        local r, g, b = match:sub(2, 2), match:sub(3, 3), match:sub(4, 4)
        local hex_color = "#" .. r .. r .. g .. g .. b .. b
        return MiniHipatterns.compute_hex_color_group(hex_color, "bg")
      end,
    },
    hsl_color = {
      -- NOTE: Partial support for CSS hsl()
      pattern = "hsl%(%d+[, ] ?%d+%%?[, ] ?%d+%%?%)",
      group = function(_, m, _)
        -- https://www.w3.org/TR/css-color-3/#hsl-color
        local function hsl_to_rgb(h, s, l)
          h, s, l = h % 360, s / 100, l / 100
          if h < 0 then
            h = h + 360
          end
          local function f(n)
            local k = (n + h / 30) % 12
            local a = s * math.min(l, 1 - l)
            return l - a * math.max(-1, math.min(k - 3, 9 - k, 1))
          end
          return f(0) * 255, f(8) * 255, f(4) * 255
        end
        local h, s, l = m:match("(%d+)[, ] ?(%d+)%%?[, ] ?(%d+)%%?")
        local r, g, b = hsl_to_rgb(h, s, l)
        local hex = string.format("#%02x%02x%02x", r, g, b)
        return MiniHipatterns.compute_hex_color_group(hex)
      end,
    },
    tailwind = {
      pattern = function()
        local ft = {
          "css",
          "html",
          "javascript",
          "javascriptreact",
          "svelte",
          "typescript",
          "typescriptreact",
          "vue",
        }
        if not vim.tbl_contains(ft, vim.bo.filetype) then
          return
        end
        return "%f[%w:-]()[%w:-]+%-[a-z%-]+%-%d+()%f[^%w:-]"
        -- compact
        -- return "%f[%w:-][%w:-]+%-()[a-z%-]+%-%d+()%f[^%w:-]"
      end,
      group = function(_, _, d)
        local match = d.full_match
        local color, shade = match:match("[%w-]+%-([a-z%-]+)%-(%d+)")
        shade = tonumber(shade)
        local bg = vim.tbl_get(tw_store.cl, color, shade)
        if bg then
          local hl = "MiniHipatternsTailwind" .. color .. shade
          if not tw_store.hl[hl] then
            tw_store.hl[hl] = true
            local bg_shade = shade == 500 and 950 or shade < 500 and 900 or 100
            local fg = vim.tbl_get(tw_store.cl, color, bg_shade)
            vim.api.nvim_set_hl(0, hl, { bg = "#" .. bg, fg = "#" .. fg })
          end
          return hl
        end
      end,
    },
  },
})

local MiniIcons = require("mini.icons")
MiniIcons.setup()

local MiniIndentscope = require("mini.indentscope")
vim.g.miniindentscope_disable = true
MiniIndentscope.setup({
  mappings = {
    object_scope = "ii",
    object_scope_with_border = "ai",
    goto_top = "[i",
    goto_bottom = "]i",
  },
  options = {
    indent_at_cursor = false,
  },
})
vim.keymap.set("n", "[I", "100[i", { remap = true, desc = "Indent first" })
vim.keymap.set("n", "]I", "100]i", { remap = true, desc = "Indent last" })
vim.keymap.set("n", "grs", function()
  vim.cmd("sil norm " .. string.rep("[i", vim.v.count - 1) .. "viiy']vaiopgv<")
end, { desc = "Unscope" })

-- local MiniKeymap = require("mini.keymap")
-- -- Auto tags
-- MiniKeymap.map_combo("i", ">", function()
--   local row, col = unpack(vim.api.nvim_win_get_cursor(0))
--   local line = vim.api.nvim_get_current_line()
--   if line:sub(col + 1, col + 1) == "<" then
--     return
--   end
--   local tag = line:sub(1, col):match("<([%l%d:%-]+)[^<>]*>$")
--   if not tag then
--     return
--   end
--   local close = ("</%s>"):format(tag)
--   row = row - 1
--   vim.api.nvim_buf_set_text(0, row, col, row, col, { close })
-- end)

local MiniMisc = require("mini.misc")
MiniMisc.setup_restore_cursor({ center = vim.g.session_center })
MiniMisc.setup_termbg_sync()

local MiniSessions = require("mini.sessions")
local root_session = function()
  local root = find_root()
  return root and (string.gsub(root, "/", "%%")) or nil
end
MiniSessions.setup({
  directory = vim.fn.stdpath("state") .. "/sessions",
  autoread = false,
  autowrite = true,
  hooks = {
    pre = {
      write = function()
        vim.fn.mkdir(MiniSessions.config.directory, "p")
      end,
    },
    post = {
      read = function()
        if vim.g.session_center then
          vim.cmd('normal! zz"')
        end
      end,
    },
  },
})
vim.cmd.cnoreabbrev("Lo", "Load")
vim.cmd.cnoreabbrev("Sa", "Save")
vim.cmd.cnoreabbrev("La", "Last")
local ncall = function(level, ...)
  local ok, err = pcall(...)
  if not ok then
    vim.notify(err, vim.log.levels[level])
  end
end
local minisession_run = function(action, get_session)
  local session = get_session()
  if not session then
    vim.notify("(mini.sessions) No session found", vim.log.levels.WARN)
  else
    ncall("WARN", MiniSessions[action], session)
  end
end
vim.api.nvim_create_user_command("Load", function()
  minisession_run("read", root_session)
end, {})
vim.api.nvim_create_user_command("Save", function()
  minisession_run("write", root_session)
end, {})
vim.api.nvim_create_user_command("Last", function()
  minisession_run("read", MiniSessions.get_latest)
end, {})
--
local load_au = vim.api.nvim_create_augroup("session_load", { clear = true })
local save_au = vim.api.nvim_create_augroup("session_save", { clear = true })
-- -- -- Load
if vim.fn.argc() == 0 then
  vim.api.nvim_create_autocmd("VimEnter", {
    desc = "Load session on `vim` with no args",
    group = load_au,
    nested = true,
    callback = function()
      -- NOTE: See `Restart`
      if not vim.g.after_restart and vim.bo.buftype == "" then
        vim.cmd("silent Load")
      end
    end,
  })
end
-- -- -- Save
vim.api.nvim_create_autocmd("VimLeave", {
  desc = "Save session on `VimLeave`",
  group = save_au,
  callback = function()
    local isnt_float = function(win)
      return vim.api.nvim_win_get_config(win).relative == ""
    end
    local non_float = vim.tbl_filter(isnt_float, vim.api.nvim_list_wins())
    if #non_float == 0 then
      return
    end
    if #non_float == 1 then
      local win = non_float[1]
      local buf = vim.api.nvim_win_get_buf(win)
      if vim.bo[buf].buftype ~= "" or vim.api.nvim_buf_get_name(buf) == "" then
        return
      end
    end
    vim.cmd("silent Save")
  end,
})

local MiniMove = require("mini.move")
MiniMove.setup({
  mappings = {
    left = "<C-h>",
    down = "<C-j>",
    up = "<C-k>",
    right = "<C-l>",
    line_left = "",
    line_down = "",
    line_up = "",
    line_right = "",
  },
})

local MiniPairs = require("mini.pairs")
MiniPairs.setup({
  -- modes = { command = true },
  mappings = {
    ["("] = { neigh_pattern = "[^\\][%s>)%]},:]" },
    ["["] = { neigh_pattern = "[^\\][%s>)%]},:]" },
    ["{"] = { neigh_pattern = "[^\\][%s>)%]},:]" },
    ['"'] = { neigh_pattern = "[%s<(%[{][%s>)%]},:]" },
    ["'"] = { neigh_pattern = "[%s<(%[{][%s>)%]},:]" },
    ["`"] = { neigh_pattern = "[%s<(%[{][%s>)%]},:]" },
    ["<"] = { action = "open", pair = "<>", neigh_pattern = "[\r%w\"'`].", register = { cr = false } },
    [">"] = { action = "close", pair = "<>", register = { cr = false } },
  },
})
require("mini.keymap").map_combo("i", "<", function()
  local line = vim.api.nvim_get_current_line()
  local col = vim.fn.col(".")
  return line:sub(col - 2, col) == "<<>" and "<Del>" or nil
end)
-- require("mini.keymap").map_combo("i", "=", function()
--   local line = vim.api.nvim_get_current_line()
--   local col = vim.fn.col(".")
--   return line:sub(col - 2, col) == "<=>" and "<Del>" or nil
-- end)

local MiniExtra = require("mini.extra")
MiniExtra.setup()

local MiniPick = require("mini.pick")
-- -- -- Syntax highlight (utils)
---@class HiExtmark : vim.api.keyset.set_extmark
---@field col? number -- NEW!
---@field row? number -- NEW!
vim.api.nvim_set_hl(0, "MiniPickMatchRanges", {
  bold = true,
  underdotted = true,
})
---@param query_range Range4? 0-based, end-exclusive
local get_ts_highlights = function(source, lang, parse_range, query_range)
  parse_range = parse_range == nil and true or parse_range
  query_range = query_range
  local is_range4 = function(r)
    return r[1] and r[2] and r[3] and r[4]
  end
  if query_range and not is_range4(query_range) then
    error("`query_range` must be Range4|nil")
  end
  local parser, err ---@type vim.treesitter.LanguageTree?, string?
  if type(source) == "number" then
    parser, err = vim.treesitter.get_parser(source, lang, { error = false })
  end
  if type(source) == "string" then
    parser, err = vim.treesitter.get_string_parser(source, lang, { error = false })
  end
  if not parser then
    error(err or "Unable to get a parser")
  end
  local ret = {}
  local prior_vals = {}
  local vim_range = function(r)
    return vim.range(r[1], r[2], r[3], r[4])
  end
  local intersect = function(r1, r2)
    local inter = vim_range(r1):intersect(vim_range(r2))
    if not inter then
      return nil
    end
    return { inter.start.row, inter.start.col, inter.end_.row, inter.end_.col }
  end
  parser:parse(parse_range)
  parser:for_each_tree(function(tstree, tree)
    if not tstree then
      return
    end
    local root_node = tstree:root()
    local root_range = { root_node:range() }
    local tsquery_range = query_range or root_range
    if not intersect(root_range, tsquery_range) then
      return
    end
    local query = vim.treesitter.query.get(tree:lang(), "highlights")
    if not query then
      return
    end
    for id, node, metadata in
      query:iter_captures(
        root_node,
        source,
        tsquery_range[1],
        tsquery_range[3],
        { start_col = tsquery_range[2], end_col = tsquery_range[4] }
      )
    do
      local capture = query.captures[id]
      if capture ~= nil and capture ~= "spell" then
        local node_text = vim.treesitter.get_node_text(node, source, metadata[id])
        local text = vim.split(node_text, "\n")
        local range = { node:range() }
        local inter = intersect(range, tsquery_range)
        if not inter then
          return
        end
        -- NOTE: row 1-based inclusive, col 0-based exclusive
        local row_start, row_end = inter[1] + 1, inter[4] == 0 and inter[3] or inter[3] + 1
        for row = row_start, row_end do
          local first, last = row == row_start, row == row_end
          local col = first and inter[2] or 0
          local line = text[row - row_start - 1] or ""
          local end_col = last and inter[4] or #line
          -- HACK: +1 `priority` for repeated columns
          local prior = tonumber(metadata.priority) or 100
          local prior_id = vim.inspect({ row, col })
          prior = prior_vals[prior_id] and prior_vals[prior_id] + 1 or prior
          prior_vals[prior_id] = prior
          --
          ret[row] = ret[row] or {}
          table.insert(ret[row], {
            row = row,
            end_row = row,
            col = col,
            end_col = end_col,
            priority = prior,
            conceal = metadata.conceal,
            hl_group = "@" .. capture .. "." .. lang,
          } --[[@as HiExtmark]])
        end
      end
    end
  end)
  local hls_flat = function(hls_tbl)
    local keys = vim.tbl_keys(hls_tbl)
    table.sort(keys)
    -- stylua: ignore
    return vim.tbl_map(function(key) return hls_tbl[key] end, keys)
  end
  -- NOTE: Return highlights grouped by line
  ---@cast ret HiExtmark[][]
  ret = hls_flat(ret)
  return ret
end
local get_lang = function(ft)
  local lang = vim.treesitter.language.get_lang(ft or "")
  if not lang then
    return nil
  end
  if not vim.treesitter.language.add(lang) then
    return nil
  end
  if not vim.api.nvim_get_runtime_file("queries/" .. lang .. "/highlights.scm", false) then
    return nil
  end
  return lang
end
local get_text_patched_highlights = function(text, ft)
  text = type(text) == "table" and table.concat(text, "\n") or text
  local lang = get_lang(ft)
  if not lang then
    return nil
  end
  -- HACK: Complete keywords in order to get highlights
  if lang == "lua" then
    local prepend = { ["end"] = "do", ["until"] = "repeat" }
    local append = { ["do"] = "end", ["then"] = "end", ["repeat"] = "until" }
    local lines = vim.split(text, "\n")
    local first, last = lines[1], lines[#lines]
    local from, to = 0, #lines
    for _, word in ipairs(vim.split(first, "%s+")) do
      local add = prepend[word]
      if add then
        table.insert(lines, 1, add)
        from, to = from + 1, to + 1
      end
    end
    for _, word in ipairs(vim.split(last, "%s+")) do
      local add = append[word]
      if add then
        table.insert(lines, add)
      end
    end
    local patched_text = table.concat(lines, "\n")
    return get_ts_highlights(patched_text, lang, true, { from, 0, to, 0 })
  end
  return get_ts_highlights(text, lang)
end
local get_buf_highlights = function(buf, with_extmarks, ln_range)
  if not vim.api.nvim_buf_is_valid(buf) then
    error(string.format("Invalid buffer: %s", buf))
  end
  ln_range = vim.tbl_extend("keep", ln_range, { -- 0-based exclusive
    [1] = 0,
    [2] = vim.api.nvim_buf_line_count(buf),
  })
  local lang = get_lang(vim.bo[buf].ft)
  if not lang then
    return {}
  end
  local range4 = { ln_range[1], 0, ln_range[2], 0 }
  local hls = get_ts_highlights(buf, lang, range4, range4) or {}
  if with_extmarks then
    local start_pos, end_pos = { ln_range[1], 0 }, { ln_range[2] - 1, -1 }
    local extm_list = vim.api.nvim_buf_get_extmarks(buf, -1, start_pos, end_pos, { details = true })
    for _, extm in ipairs(extm_list) do
      local row = extm[2] + 1
      local i = ln_range[1] - extm[2] + 1
      local e = extm[4]
      hls[i] = hls[i] or {}
      if e then
        e.sign_name = nil
        e.sign_text = nil
        e.ns_id = nil
        e.end_row = nil
        e.row = row ---@diagnostic disable-line: inject-field
        e.col = extm[3] ---@diagnostic disable-line: inject-field
        if e.virt_text_pos and not vim.tbl_contains({ "eol", "overlay", "right_align", "inline" }, e.virt_text_pos) then
          e.virt_text = nil
          e.virt_text_pos = nil
        end
        table.insert(hls[i], e)
      end
    end
  end
  return hls
end
local norm_hl = function(hl, row, col_offset)
  -- hl = vim.deepcopy(hl, true)
  row, col_offset = row or hl.row, col_offset or 0
  local col = math.max(0, col_offset + hl.col)
  hl.end_row = (hl.end_row and hl.row) and (row + hl.end_row - hl.row) or hl.end_row
  hl.end_col = (hl.end_col and hl.col) and (col + hl.end_col - hl.col) or hl.end_col
  hl.row = nil
  hl.col = nil
  return row, col, hl
end
local minipick_hl_ns = vim.api.nvim_create_namespace("minipick_hl")
local pick_colorize = function(buf, data, get_hls)
  vim.api.nvim_buf_clear_namespace(buf, minipick_hl_ns, 0, -1)
  local lines = vim.api.nvim_buf_get_lines(buf, 0, -1, true)
  for i = 1, #data do
    local item, line = data[i], lines[i]
    local start, hls = get_hls(item, line)
    if start and hls and not vim.tbl_isempty(hls) then
      local row_start, col_offset = i - 1, start - 1
      -- NOTE: To prevent cache changes
      hls = vim.deepcopy(hls, true)
      for j, row_hls in ipairs(hls) do
        local row = row_start + j - 1
        for _, hl in ipairs(row_hls) do
          vim.api.nvim_buf_set_extmark(buf, minipick_hl_ns, norm_hl(hl, row, col_offset))
        end
      end
    end
  end
end
local minipick_cache = {}
local pick_cache = function(id, func)
  if not vim.list_contains({ "string", "number" }, type(id)) then
    error("Cache 'id' must be 'string' or 'number'")
  end
  if minipick_cache[id] == nil then
    minipick_cache[id] = { func() }
  end
  return unpack(minipick_cache[id])
end
vim.api.nvim_create_autocmd("User", {
  pattern = "MiniPickStop",
  callback = function()
    minipick_cache = {}
  end,
})
-- -- -- Overrides (+colors)
MiniPick.registry.buf_lines = function(local_opts, opts)
  local find_pattern = local_opts.scope == "all" and "^.-│.-│()" or "^.-│()"
  local show = function(buf, data, query)
    MiniPick.default_show(buf, data, query, opts)
    pick_colorize(buf, data, function(item, line)
      local item_buf, row = item.bufnr, item.lnum
      local id = vim.inspect({ item_buf, row })
      return pick_cache(id, function()
        local start = string.match(line, find_pattern)
        local hls = get_buf_highlights(item_buf, true, { row - 1, row })
        return start, hls
      end)
    end)
  end
  opts = vim.tbl_deep_extend("keep", opts or {}, { source = { show = show } })
  return MiniExtra.pickers.buf_lines(local_opts, opts)
end
MiniPick.registry.git_hunks = function(local_opts, opts)
  local choose_marked = function(items)
    if vim.tbl_isempty(items) then
      items = { MiniPick.get_picker_matches().current }
    end
    local patches = {}
    for _, item in ipairs(items) do
      vim.list_extend(patches, item.header)
      vim.list_extend(patches, item.hunk)
    end
    local cmd = { "git", "apply", "--cached" }
    if local_opts.scope == "staged" then
      table.insert(cmd, "--reverse")
    end
    vim.system(cmd, { stdin = patches })
  end
  local show = function(buf, data, query)
    MiniPick.default_show(buf, data, query, opts)
    -- NOTE: Replace `hunk header` with the first changed line [+-]
    --       See https://github.com/nvim-mini/mini.nvim/discussions/2190
    local lines = vim.api.nvim_buf_get_lines(buf, 0, #data, true)
    for i = 1, #data do
      local item, line = data[i], lines[i]
      local first_changed = vim.iter(item.hunk):find(function(l)
        return string.match(l, "^[+-]")
      end)
      if first_changed then
        local row_0 = i - 1
        local col_0 = string.match(line, "^.-│.-│()") - 1
        line = string.gsub(first_changed, "^([+-])%s*", "%1 ")
        vim.api.nvim_buf_set_text(buf, row_0, col_0, row_0, -1, { line })
      end
    end
    -- Color lines
    pick_colorize(buf, data, function(item, line)
      local id, start, code = string.match(line, "^(.-│.-│)[+-]()(.*)")
      return pick_cache(id, function()
        local file = item.path
        local ft = vim.filetype.match({ filename = file, contents = { code } })
        return start, get_text_patched_highlights(code, ft)
      end)
    end)
  end
  opts = vim.tbl_deep_extend("keep", opts or {}, { source = { choose_marked = choose_marked, show = show } })
  return MiniExtra.pickers.git_hunks(local_opts, opts)
end
local grep_show = function(buf, data, query, opts)
  opts = opts or {}
  MiniPick.default_show(buf, data, query, opts)
  pick_colorize(buf, data, function(item, line)
    local file, row, col, code = unpack(vim.split(item, "%z"))
    local id = vim.inspect({ file, row, col })
    return pick_cache(id, function()
      local start = string.match(line, "^.-│.-│.-│()")
      local ft = vim.filetype.match({ filename = file, contents = { code } })
      return start, get_text_patched_highlights(code, ft)
    end)
  end)
end
MiniPick.registry.grep = function(local_opts, opts)
  local show = grep_show
  opts = vim.tbl_deep_extend("keep", opts or {}, { source = { show = show } })
  return MiniPick.builtin.grep(local_opts, opts)
end
MiniPick.registry.grep_live = function(local_opts, opts)
  local_opts = vim.tbl_extend("keep", local_opts or {}, { globs = {} })
  opts = vim.tbl_extend("keep", opts or {}, { source = {} })
  local cwd = vim.fs.abspath(opts.source.cwd or vim.fn.getcwd())
  local set_items_opts = { do_match = false, querytick = MiniPick.get_querytick() }
  local rg_cmd = function(pattern, globs)
    local cmd =
      { "rg", "--column", "--line-number", "--no-heading", "--field-match-separator", "\\x00", "--color=never" }
    for _, g in ipairs(globs) do
      vim.list_extend(cmd, { "--glob", g })
    end
    local case = vim.o.ignorecase and (vim.o.smartcase and "smart-case" or "ignore-case") or "case-sensitive"
    vim.list_extend(cmd, { "--" .. case })
    vim.list_extend(cmd, { "--", pattern })
    return cmd
  end
  local parse_globs = function(query_str)
    local escape = function(str)
      return str:gsub("\\ ", "\1")
    end
    local unescape = function(str)
      return str:gsub("\1", "\\ ")
    end
    local after_split = vim.split(escape(query_str), "%s+", { trimempty = true })
    return vim.tbl_map(unescape, after_split)
  end
  local glob_mode = false
  local glob_query = {}
  local pattern_query = {}
  local query_globs = {}
  local globs = {}
  local process
  local match = function(_, _, query)
    pcall(vim.loop.process_kill, process)
    if MiniPick.get_querytick() == set_items_opts.querytick then
      return
    end
    if glob_mode then
      glob_query = query
      query_globs = parse_globs(table.concat(query))
      globs = {}
      vim.list_extend(globs, local_opts.globs)
      vim.list_extend(globs, query_globs)
    else
      pattern_query = query
    end
    if vim.tbl_isempty(pattern_query) and vim.tbl_isempty(query_globs) then
      return MiniPick.set_picker_items({}, set_items_opts)
    end
    set_items_opts.querytick = MiniPick.get_querytick()
    local cmd = rg_cmd(table.concat(pattern_query), globs)
    process = MiniPick.set_picker_items_from_cli(cmd, { set_items_opts = set_items_opts, spawn_opts = { cwd = cwd } })
  end
  local toggle_glob = function()
    glob_mode = not glob_mode
    if glob_mode then
      MiniPick.set_picker_opts({ source = { name = "Grep live (rg*)" } })
      MiniPick.set_picker_query(glob_query)
    else
      local suffix = vim.tbl_isempty(globs) and "" or " | " .. table.concat(globs, ", ")
      local source_name = string.format("Grep live (rg%s)", suffix)
      MiniPick.set_picker_opts({ source = { name = source_name } })
      MiniPick.set_picker_query(pattern_query)
    end
  end
  local show = grep_show
  return MiniPick.start(vim.tbl_deep_extend("force", opts or {}, {
    source = {
      name = "Grep live (rg)",
      items = {},
      match = match,
      show = show,
    },
    mappings = {
      toggle_glob = { char = "<C-o>", func = toggle_glob },
    },
  }))
end
MiniPick.registry.grep_todo = function(local_opts, opts)
  local words = { "FIX", "FIXME", "BUG", "NOTE", "TODO", "FEAT", "WARN", "WARNING", "HACK", "PERF" }
  local pattern = "(" .. table.concat(words, "|") .. ")[ :]"
  local_opts = vim.tbl_extend("keep", local_opts or {}, { pattern = pattern })
  return MiniPick.registry.grep(local_opts, opts)
end
MiniPick.registry.hipatterns = function(local_opts, opts)
  local show = function(buf, data, query)
    MiniPick.default_show(buf, data, query, opts)
    pick_colorize(buf, data, function(item, line)
      local item_buf, row, col = item.bufnr, item.lnum, item.col
      local id = vim.inspect({ item_buf, row, col })
      return pick_cache(id, function()
        local start = string.match(line, "^.-│.-│.-│.-│()")
        local hls = get_buf_highlights(item_buf, false, { row - 1, row })
        return start, hls
      end)
    end)
    -- NOTE: After colorize
    for i = 1, #data do
      local item = data[i]
      local highlighter, hl_group = item.highlighter, item.hl_group
      local row, end_col = i - 1, #highlighter
      local extm = { hl_group = hl_group, end_row = row, end_col = end_col }
      vim.api.nvim_buf_set_extmark(buf, minipick_hl_ns, row, 0, extm)
    end
  end
  opts = vim.tbl_deep_extend("keep", opts or {}, { source = { show = show } })
  return MiniExtra.pickers.hipatterns(local_opts, opts)
end
MiniPick.registry.history = function(local_opts, opts)
  local show = function(buf, data, query)
    MiniPick.default_show(buf, data, query, opts)
    pick_colorize(buf, data, function(item, line)
      local id = item
      return pick_cache(id, function()
        local start = string.match(line, "^: ()")
        if start then
          local code = string.sub(line, start)
          local ft = "vim"
          return start, get_text_patched_highlights(code, ft)
        end
      end)
    end)
  end
  opts = vim.tbl_deep_extend("keep", opts or {}, { source = { show = show } })
  return MiniExtra.pickers.history(local_opts, opts)
end
MiniPick.registry.lsp = function(local_opts, opts)
  local find_pattern = local_opts.scope == "document_symbol" and "^.-[.-]()(.*)" or "^.-│.-│.-│()(.*)"
  local show = function(buf, data, query)
    MiniPick.default_show(buf, data, query, opts)
    pick_colorize(buf, data, function(item, line)
      local file, row, col = item.path, item.lnum, item.col
      local id = vim.inspect({ file, row, col })
      return pick_cache(id, function()
        local start, code = string.match(line, find_pattern)
        local ft = vim.filetype.match({ filename = file, contents = { code } })
        return start, get_text_patched_highlights(code, ft)
      end)
    end)
  end
  opts = vim.tbl_deep_extend("keep", opts or {}, { source = { show = show } })
  return MiniExtra.pickers.lsp(local_opts, opts)
end
-- -- -- Overrides (other)
MiniPick.registry.colorschemes = function(local_opts, opts)
  local aug = vim.api.nvim_create_augroup("pick_colors", { clear = true })
  local fake_buf = vim.api.nvim_create_buf(false, true)
  local cl = vim.g.colors_name or "default"
  local bg = vim.o.background or "dark"
  local preview = function(colors)
    local matches = MiniPick.get_picker_matches()
    if matches then
      local item = colors or matches.current
      local func = MiniPick.get_picker_opts().source.preview
      pcall(func, fake_buf, item)
      vim.o.background = bg
    end
  end
  local match_current = function()
    local matches = MiniPick.get_picker_matches()
    local current = vim.iter(matches.all_inds):find(function(i)
      return cl == matches.all[i]
    end)
    if current then
      MiniPick.set_picker_match_inds({ current }, "current")
    end
  end
  local on_move = function()
    vim.schedule(preview)
  end
  vim.api.nvim_create_autocmd("User", { pattern = "MiniPickStart", group = aug, callback = match_current })
  vim.api.nvim_create_autocmd("User", { pattern = "MiniPickMatch", group = aug, callback = on_move })
  vim.api.nvim_create_autocmd("User", {
    pattern = "MiniPickStop",
    group = aug,
    once = true,
    callback = function()
      vim.api.nvim_clear_autocmds({ group = aug })
      vim.api.nvim_buf_delete(fake_buf, { unload = true })
    end,
  })
  local remap_move = function(char, keys)
    return {
      char = char,
      func = function()
        vim.api.nvim_input(keys)
        on_move()
      end,
    }
  end
  return MiniExtra.pickers.colorschemes(
    local_opts,
    vim.tbl_deep_extend("keep", opts or {}, {
      source = {
        choose = function(item)
          vim.cmd.colorscheme(item)
          vim.g.COLORS_NAME = vim.g.colors_name
          vim.g.COLORS_BG = vim.o.background
          vim.cmd.wshada()
        end,
      },
      mappings = {
        match_current = {
          char = "<C-0>",
          func = function()
            match_current()
            on_move()
          end,
        },
        change_bg = {
          char = "<C-o>",
          func = function()
            bg = vim.o.background == "dark" and "light" or "dark"
            vim.o.background = bg
          end,
        },
        move_start = "<C-Home>",
        scroll_down = "<PageDown>",
        scroll_up = "<PageUp>",
        move_start_alt = remap_move("<C-g>", "<C-Home>"),
        move_down_alt = remap_move("<C-n>", "<Down>"),
        move_up_alt = remap_move("<C-p>", "<Up>"),
        move_down_2_alt = remap_move("<C-j>", "<Down>"),
        move_up_2_alt = remap_move("<C-k>", "<Up>"),
        scroll_down_alt = remap_move("<C-f>", "<PageDown>"),
        scroll_up_alt = remap_move("<C-b>", "<PageUp>"),
      },
    })
  )
end
MiniPick.registry.files = function(_, opts)
  local cli_opts = {
    command = { "fd", "-t=f", "-H", "-I", "-E=.git", "-E=node_modules" },
  }
  local show = function(buf, items, query)
    MiniPick.default_show(buf, items, query, { show_icons = true })
  end
  return MiniPick.builtin.cli(
    cli_opts,
    vim.tbl_deep_extend("keep", opts or {}, {
      source = {
        name = "Files (fd)",
        show = show,
      },
      mappings = {
        open_file = {
          char = "<S-Enter>",
          func = function()
            local current = MiniPick.get_picker_matches().current
            if MiniFiles then
              vim.schedule(function()
                MiniFiles.open(current, true)
              end)
              return true
            end
          end,
        },
      },
    })
  )
end
local run_keys = function(keys, rep)
  vim.api.nvim_input(string.rep(keys, rep or 1))
end
local pick_move_caret = function(next_caret)
  local caret = MiniPick.get_picker_state().caret
  local query = MiniPick.get_picker_query()
  next_caret = math.max(1, math.min(next_caret, #query + 1))
  local move = next_caret - caret
  run_keys(move >= 0 and "<Right>" or "<Left>", math.abs(move))
end
local pick_remap = function(char, keys)
  return {
    char = char,
    func = function()
      run_keys(keys)
    end,
  }
end
MiniPick.setup({
  mappings = {
    choose_marked = "<C-Enter>",
    quickfix = {
      char = "<C-q>",
      func = function()
        local all_items = MiniPick.get_picker_items()
        local marked = MiniPick.get_picker_matches().marked
        local choose = vim.tbl_isempty(marked) and all_items or marked
        MiniPick.default_choose_marked(choose, { list_type = "quickfix" })
      end,
    },
    -- Moves
    caret_start = {
      char = "<Home>",
      func = function()
        pick_move_caret(1)
      end,
    },
    caret_end = {
      char = "<End>",
      func = function()
        pick_move_caret(math.huge)
      end,
    },
    prev_word = {
      char = "<C-Left>",
      func = function()
        local query_str = table.concat(MiniPick.get_picker_query())
        local caret = MiniPick.get_picker_state().caret
        local regex = vim.regex([=[\([^[:keyword:][:space:]]\+\|\k\+\)\s*$]=])
        local from, _ = regex:match_str(string.sub(query_str, 1, caret - 1))
        pick_move_caret(from and from + 1 or 1)
      end,
    },
    next_word = {
      char = "<C-Right>",
      func = function()
        local query_str = table.concat(MiniPick.get_picker_query())
        local caret = MiniPick.get_picker_state().caret
        local regex = vim.regex([=[^\([^[:keyword:][:space:]]\+\|\k\+\)\s*]=])
        local _, to = regex:match_str(string.sub(query_str, caret))
        pick_move_caret(to and to + caret or math.huge)
      end,
    },
    prev_before_space = {
      char = "<C-S-Left>",
      func = function()
        local query_str = table.concat(MiniPick.get_picker_query())
        local caret = MiniPick.get_picker_state().caret
        local search_str = string.sub(query_str, 1, caret - 1)
        local word_start = string.find(search_str, "%S+%s*$")
        pick_move_caret(word_start or 1)
      end,
    },
    next_before_space = {
      char = "<C-S-Right>",
      func = function()
        local query_str = table.concat(MiniPick.get_picker_query())
        local caret = MiniPick.get_picker_state().caret
        local word_end = string.find(query_str, "%f[%s]", caret + 1)
        pick_move_caret(word_end or #query_str + 1)
      end,
    },
    -- Remaps
    move_down_alt = pick_remap("<C-j>", "<C-n>"),
    move_up_alt = pick_remap("<C-k>", "<C-p>"),
    caret_prev_alt = pick_remap("<C-a>", "<C-Left>"),
    caret_next_alt = pick_remap("<C-e>", "<C-Right>"),
  },
})

local buf_name = function(buf) ---@diagnostic disable-line: redefined-local
  return vim.api.nvim_buf_get_name(buf or 0)
end
-- stylua: ignore start
vim.keymap.set("n", "<Leader>sb", function() MiniPick.registry.buffers() end, { desc = "Search buffers" })
vim.keymap.set("n", "<Leader>sf", function() MiniPick.registry.files() end, { desc = "Search files" })
vim.keymap.set("n", "<Leader>sg", function() MiniPick.registry.grep_live() end, { desc = "Search grep" })
vim.keymap.set("n", "<Leader>sl", function() MiniPick.registry.buf_lines({ scope = "current" }) end, { desc = "Search lines (buf)" })
vim.keymap.set("n", "<Leader>sL", function() MiniPick.registry.buf_lines({ scope = "all" }) end, { desc = "Search lines (all)" })
vim.keymap.set("n", "<Leader>sa", function() MiniPick.registry.git_hunks({ path = buf_name(), scope = "staged" }) end, { desc = "Search added hunks (buf)" })
vim.keymap.set("n", "<Leader>sA", function() MiniPick.registry.git_hunks({ scope = "staged" }) end, { desc = "Search added hunks (all)" })
vim.keymap.set("n", "<Leader>sm", function() MiniPick.registry.git_hunks() end, { desc = "Search modified hunks (all)" })
vim.keymap.set("n", "<Leader>sM", function() MiniPick.registry.git_hunks({ path = buf_name() }) end, { desc = "Search modified hunks (buf)" })
vim.keymap.set("n", "<Leader>sc", function() MiniPick.registry.git_commits({ path = buf_name() }) end, { desc = "Search commits (buf)" })
vim.keymap.set("n", "<Leader>sC", function() MiniPick.registry.git_commits() end, { desc = "Search commits (all)" })
vim.keymap.set("n", "<Leader>sd", function() MiniPick.registry.diagnostic({ scope = "current" }) end, { desc = "Search diagnostics (buf)" })
vim.keymap.set("n", "<Leader>sD", function() MiniPick.registry.diagnostic({ scope = "all" }) end, { desc = "Search diagnostics (workspace)" })
vim.keymap.set("n", "<Leader>sR", function() MiniPick.registry.lsp({ scope = "references" }) end, { desc = "Search LSP refs" })
vim.keymap.set("n", "<Leader>ss", function() MiniPick.registry.lsp({ scope = "document_symbol" }) end, { desc = "Search LSP symbols (doc)" })
vim.keymap.set("n", "<Leader>sS", function() MiniPick.registry.lsp({ scope = "workspace_symbol_live" }) end, { desc = "Search LSP symbols (workspace)" })
vim.keymap.set("n", "<Leader>sh", function() MiniPick.registry.help() end, { desc = "Search help" })
vim.keymap.set("n", "<Leader>sH", function() MiniPick.registry.hl_groups() end, { desc = "Search highlights" })
vim.keymap.set("n", "<Leader>sr", function() MiniPick.registry.resume() end, { desc = "Search resume" })
vim.keymap.set("n", "<Leader>s/", function() MiniPick.registry.history({ scope = "/" }) end, { desc = "Search '/' history" })
vim.keymap.set("n", "<Leader>s:", function() MiniPick.registry.history({ scope = ":" }) end, { desc = "Search cmd history" })
vim.keymap.set("n", "<Leader>s'", function() MiniPick.registry.marks() end, { desc = "Search marks" })
vim.keymap.set("n", "<Leader>s`", function() MiniPick.registry.registers() end, { desc = "Search register" })
vim.keymap.set("n", "<Leader>so", function() MiniPick.registry.colorschemes() end, { desc = "Search colorschemes" })
-- stylua: ignore end

local MiniVisits = require("mini.visits")
MiniVisits.setup()
-- stylua: ignore start
vim.keymap.set("n", "<Leader>v", function() MiniVisits.add_label("favorites") end, { desc = 'Add "core" label' })
vim.keymap.set("n", "<Leader>V", function() MiniVisits.remove_label("favorites") end, { desc = 'Remove "core" label' })
vim.keymap.set("n", "<Leader>sv", function() MiniPick.registry.visit_paths({ filter = "favorites" }) end, { desc = "Search visits (cwd)" })
vim.keymap.set("n", "<Leader>sV", function() MiniPick.registry.visit_paths({ cwd = "", filter = "favorites" }) end, { desc = "Search visits (all)" })
-- stylua: ignore end

-- -- Treesitter

vim.treesitter.language.register("tsx", "typescriptreact")

local ts_install = vim.g.ts_install or {}
local ts_filetypes = vim
  .iter(ts_install)
  :map(function(lang)
    return vim.treesitter.language.get_filetypes(lang)
  end)
  :flatten()
  :totable()

require("nvim-treesitter").install(ts_install)

vim.api.nvim_create_autocmd("FileType", {
  desc = "Setup treesitter for a buffer",
  pattern = ts_filetypes,
  group = vim.api.nvim_create_augroup("ts_setup", { clear = true }),
  callback = function(e)
    vim.treesitter.start(e.buf)
    vim.wo.foldmethod = "expr"
    vim.wo.foldexpr = "v:lua.vim.treesitter.foldexpr()"
    vim.bo.indentexpr = "v:lua.require'nvim-treesitter'.indentexpr()"
  end,
})

local ts_swap = require("nvim-treesitter-textobjects.swap")
-- stylua: ignore
vim.keymap.set("n", "<Leader>a", function() ts_swap.swap_next("@parameter.inner") end, { desc = "Swap arg next" })
-- stylua: ignore
vim.keymap.set("n", "<Leader>A", function() ts_swap.swap_previous("@parameter.inner") end, { desc = "Swap arg prev" })

-- -- Treesj

require("treesj").setup({ max_join_length = 750, use_default_keymaps = false })
-- stylua: ignore
vim.keymap.set("n", "gs", function() require("treesj").toggle() end)

-- -- Mason

local mason_install = vim.g.mason_install or {}
require("mason").setup()
local mason_available = require("mason-registry").get_installed_package_names()
local mason_rest = {}
for _, inst in ipairs(mason_install) do
  if not vim.list_contains(mason_available, inst) then
    table.insert(mason_rest, inst)
  end
end
if #mason_rest > 0 then
  vim.cmd("MasonInstall " .. table.concat(mason_rest, " "))
end

-- -- LSP

local lsp_enable = vim.g.lsp_enable or {}
vim.lsp.enable(lsp_enable)
vim.diagnostic.config({ virtual_text = true })

vim.keymap.set("n", "gK", function()
  local state = not vim.diagnostic.config().virtual_text
  vim.diagnostic.config({ virtual_text = state, underline = state })
end, { desc = "Toggle diagnostic" })

vim.keymap.set("n", "gI", function()
  vim.lsp.inlay_hint.enable(not vim.lsp.inlay_hint.is_enabled())
end, { desc = "Toggle inlay" })

vim.keymap.set("n", "gR", function()
  vim.lsp.buf.clear_references()
  vim.g.document_highlight = not vim.g.document_highlight
end, { desc = "Toggle document highlight" })

local dochl_au = vim.api.nvim_create_augroup("doc_highlight", { clear = true })
vim.api.nvim_create_autocmd("LspAttach", {
  desc = "Setup document highlight",
  callback = function(e)
    local client = assert(vim.lsp.get_client_by_id(e.data.client_id))
    local buf = e.buf
    if not client:supports_method(vim.lsp.protocol.Methods.textDocument_documentHighlight) then
      return
    end
    local cleanup = false
    vim.api.nvim_create_autocmd({ "CursorHold", "CursorHoldI" }, {
      group = dochl_au,
      buffer = buf,
      callback = function()
        if vim.g.document_highlight then
          vim.lsp.buf.document_highlight()
          cleanup = true
        end
      end,
    })
    vim.api.nvim_create_autocmd({ "CursorMoved", "CursorMovedI" }, {
      group = dochl_au,
      buffer = buf,
      callback = function()
        if cleanup then
          vim.lsp.buf.clear_references()
          cleanup = false
        end
      end,
    })
  end,
})

-- -- -- Undim current diagnostic

local undim_au = vim.api.nvim_create_augroup("undim_diagnostic", { clear = false })
local function toggle_undim(buf, client_id)
  buf = buf or 0
  local client = assert(vim.lsp.get_client_by_id(client_id), "Unable to get LSP client by provided 'client_id'")
  local tagSupport = client.capabilities.textDocument.diagnostic.tagSupport.valueSet
  if not vim.list_contains(tagSupport, 1) then
    return false
  end
  local name = string.format("nvim.nvim.lsp.%s.%d.diagnostic.underline", client.name, client.id)
  local ns = vim.api.nvim_create_namespace(name)
  local iter_unnecessary = function()
    local diagnostics = vim.diagnostic.get(buf, { severity = vim.diagnostic.severity.HINT })
    return vim.iter(diagnostics):filter(function(diagn)
      return diagn._tags and diagn._tags.unnecessary
    end)
  end
  local set_hl = function(diagn)
    vim.api.nvim_buf_set_extmark(buf, ns, diagn.lnum, diagn.col, {
      hl_group = "DiagnosticUnnecessary",
      end_line = diagn.end_lnum,
      end_col = diagn.end_col,
      strict = false,
    })
  end
  local del_hl = function(diagn)
    local from = { diagn.lnum, diagn.col }
    local to = { diagn.end_lnum, diagn.end_col }
    local extmarks = vim.api.nvim_buf_get_extmarks(buf, ns, from, to, {})
    for _, extm in ipairs(extmarks) do
      vim.api.nvim_buf_del_extmark(buf, ns, extm[1])
    end
  end
  local state = vim.b[buf].undim_diagnostics or {}
  state[client.id] = not state[client.id]
  vim.b[buf].undim_diagnostics = state
  if not state[client.id] then
    vim.api.nvim_clear_autocmds({ buffer = buf, group = undim_au })
    vim.api.nvim_buf_clear_namespace(buf, ns, 0, -1)
    for diagn in iter_unnecessary() do
      set_hl(diagn)
    end
  else
    local update = function()
      vim.api.nvim_buf_clear_namespace(buf, ns, 0, -1)
      --
      local cursor = vim.api.nvim_win_get_cursor(0)
      local lnum, col = cursor[1] - 1, cursor[2]
      local in_range = function(diagn)
        return (lnum >= diagn.lnum and lnum <= diagn.end_lnum) --
          and (diagn.lnum ~= diagn.end_lnum or col < diagn.end_col)
      end
      for diagn in iter_unnecessary() do
        if in_range(diagn) then
          del_hl(diagn)
        else
          set_hl(diagn)
        end
      end
    end
    vim.api.nvim_create_autocmd("ModeChanged", {
      buffer = buf,
      group = undim_au,
      callback = function()
        local mode = vim.fn.mode()
        if mode == "n" then
          update()
        elseif mode == "c" then
        else
          vim.api.nvim_buf_clear_namespace(buf, ns, 0, -1)
        end
      end,
    })
    vim.api.nvim_create_autocmd({ "CursorHold", "DiagnosticChanged" }, {
      buffer = buf,
      group = undim_au,
      callback = function()
        if vim.fn.mode() == "n" then
          update()
        end
      end,
    })
  end
end
--
vim.api.nvim_create_autocmd("LspAttach", {
  desc = "Undim unused code in normal mode",
  group = vim.api.nvim_create_augroup("undim_diagnostic", { clear = true }),
  callback = function(e)
    local buf, client_id = e.buf, e.data.client_id
    local state = vim.b[buf].undim_unnecessary or {}
    if not state[client_id] then
      toggle_undim(e.buf, e.data.client_id)
    end
  end,
})

-- -- -- Lsp progress

do
  local au = vim.api.nvim_create_augroup("lsp_progress", { clear = true })
  local ns = vim.api.nvim_create_namespace("lsp_progress")
  local timer = assert(vim.uv.new_timer())
  local buf = -1
  local win = -1
  -- Utils
  local minmax = function(val, min, max)
    return math.floor(math.max(min, math.min(val, max)))
  end
  local text_overflow = function(line, max_width)
    if #line <= max_width then
      return line
    end
    local ell = "..."
    local cut = max_width - vim.fn.strwidth(ell)
    if cut <= 0 then
      return ell .. line
    end
    return line:sub(1, cut) .. ell
  end
  -- Notify
  local lsp_notify = function(lines, hl, keep_ms)
    hl = hl or "Comment"
    keep_ms = keep_ms or nil
    if vim.tbl_isempty(lines) then
      return
    end
    local vpad, hpad = 0, 0
    local min_width, min_height = 1, 1
    local max_width, max_height = vim.o.columns / 3, vim.o.lines - 5
    --
    local text_width = vim.iter(lines):fold(1, function(max, val)
      return math.max(max, #val)
    end)
    local width = math.floor(minmax(text_width, min_width, max_width))
    local height = math.floor(minmax(#lines, min_height, max_height))
    local win_config = { ---@type vim.api.keyset.win_config
      relative = "editor",
      anchor = "SE",
      row = vim.o.lines - 2,
      col = vim.o.columns,
      width = width + hpad * 2,
      height = height + vpad * 2,
      zindex = 100,
      style = "minimal",
      border = "single",
      focusable = false,
      noautocmd = true,
    }
    -- Create/update window
    if not vim.api.nvim_buf_is_valid(buf) then
      buf = vim.api.nvim_create_buf(false, true)
      vim.bo[buf].ft = "lsp_progress"
    end
    if not vim.api.nvim_win_is_valid(win) then
      win = vim.api.nvim_open_win(buf, false, win_config)
      vim.wo[win].eventignorewin = "WinClosed"
      vim.wo[win].winhighlight = "Search:None,CurSearch:None"
    else
      vim.api.nvim_win_set_config(win, win_config)
    end
    --
    local buf_lines = lines
    -- Cut lines
    local cut_edge = vim.api.nvim_win_get_width(win) - hpad * 2
    for i, line in ipairs(buf_lines) do
      buf_lines[i] = text_overflow(line, cut_edge)
    end
    -- Pad lines
    local padded = {}
    local hp = string.rep(" ", hpad)
    local vline = string.rep(" ", width + hpad * 2)
    local vp = vim.fn["repeat"]({ vline }, vpad)
    vim.list_extend(padded, vp)
    for _, line in ipairs(lines) do
      table.insert(padded, hp .. line .. hp)
    end
    vim.list_extend(padded, vp)
    buf_lines = padded
    -- Set lines
    vim.api.nvim_buf_set_lines(buf, 0, -1, false, buf_lines)
    vim.hl.range(buf, ns, hl, { 0, 0 }, { #buf_lines, -1 })
    -- Shedule closing
    if keep_ms and keep_ms > 1 then
      timer:start(keep_ms, 0, function()
        timer:stop()
        vim.schedule(function()
          if vim.api.nvim_win_is_valid(win) then
            vim.api.nvim_win_close(win, true)
          end
        end)
      end)
    end
  end
  -- Setup
  vim.api.nvim_create_autocmd("LspProgress", {
    desc = "Show LSP progress status",
    group = au,
    callback = function()
      local msg = string.gsub(vim.lsp.status(), "^%s*%d+%%: ", "")
      local msg_lines = vim.split(msg, ", ")
      -- e.data.params.value.kind == "end"
      lsp_notify(msg_lines, "LspProgress", 1500)
    end,
  })
end

-- -- Debug

local dap = require("dap")
local dap_view = require("dap-view")
dap_view.setup()
require("nvim-dap-virtual-text").setup()

-- vim.keymap.set("n", "<Leader>dq", "<nop>", { desc = "Quit" })
-- MiniClue.gen_clues.debug = function()
--   return {
--     { mode = "n", keys = "<Leader>dq" },
--     { mode = "n", keys = "<Leader>dc", postkeys = "<Leader>d" },
--   }
-- end
-- vim.list_extend(MiniClue.config.triggers, { mode = "n", keys = "<Leader>d" })
-- vim.list_extend(MiniClue.config.clues, MiniClue.gen_clues.debug())

-- stylua: ignore start
vim.keymap.set("n", "<Leader>b", function() dap.toggle_breakpoint() end, { desc = "Breakpoint" })
vim.keymap.set("n", "<Leader>B", function() dap.set_breakpoint(vim.fn.input('Breakpoint condition: ')) end, { desc = "Breakpoint condition" })
vim.keymap.set("n", "<Leader>dc", function() dap.continue() end, { desc = "Run/continue" })
vim.keymap.set("n", "<Leader>dp", function() dap.pause() end, { desc = "Pause" })
vim.keymap.set("n", "<Leader>di", function() dap.step_into() end, { desc = "Step into" })
vim.keymap.set("n", "<Leader>do", function() dap.step_over() end, { desc = "Step over" })
vim.keymap.set("n", "<Leader>dO", function() dap.step_out() end, { desc = "Step out" })
vim.keymap.set("n", "<Leader>db", function() dap.step_back() end, { desc = "Debug step back" })
vim.keymap.set("n", "<Leader>df", function() dap.restart_frame() end, { desc = "Debug step back" })
vim.keymap.set("n", "<Leader>dl", function() dap.run_last() end, { desc = "Run Last" })
vim.keymap.set("n", "<Leader>dq", function() dap.terminate() end, { desc = "Terminate" })
vim.keymap.set("n", "<Leader>de", function() dap.eval(nil, { enter = true }) end, { desc = "Eval" })
vim.keymap.set("n", "<Leader>dw", function() dap_view.toggle() end, { desc = "Widgets" })
--
dap.listeners.before.attach.dapui_config = function() dap.view.open() end
dap.listeners.before.launch.dapui_config = function() dap.view.open() end
dap.listeners.before.event_terminated.dapui_config = function() dap_view.close() end
dap.listeners.before.event_exited.dapui_config = function() dap_view.close() end
-- stylua: ignore end

-- -- -- Go

-- https://codeberg.org/mfussenegger/nvim-dap/wiki/Debug-Adapter-installation#go-using-delve-directly
dap.adapters.delve = function(callback, config)
  if config.mode == "remote" and config.request == "attach" then
    callback({
      type = "server",
      host = config.host or "127.0.0.1",
      port = config.port or "38697",
    })
  else
    callback({
      type = "server",
      port = "${port}",
      executable = {
        command = "dlv",
        args = { "dap", "-l", "127.0.0.1:${port}", "--log", "--log-output=dap" },
        detached = vim.fn.has("win32") == 0,
      },
    })
  end
end
dap.configurations.go = {
  {
    type = "delve",
    name = "Debug",
    request = "launch",
    program = "${file}",
  },
  {
    type = "delve",
    name = "Debug test",
    request = "launch",
    mode = "test",
    program = "${file}",
  },
  {
    type = "delve",
    name = "Debug test (go.mod)",
    request = "launch",
    mode = "test",
    program = "./${relativeFileDirname}",
  },
}

-- Custom

-- -- Format

---@class FormatBufOpts
---@field cmd string[]
---@field stdin? [integer,integer]
---@field range? [integer,integer]
---@field transform? fun(out: string): string[]
---@field diff? "any"|"none"|"overlap"|"contain"
---@field diff_algorithm? "myers"|"minimal"|"patience"|"histogram"
---@field timeout? integer
---@field silent? boolean
---@field after_exit? fun(out: vim.SystemCompleted)

---@param buf? integer
---@param opts? FormatBufOpts
local function format_buf(buf, opts)
  buf = buf or 0
  opts = vim.tbl_extend("keep", opts or {}, {
    cmd = nil,
    stdin = {}, -- [line1, line2)
    range = {}, -- [line1, line2)
    transform = function(out)
      return vim.split(out, "\n")
    end,
    diff = "overlap",
    diff_algorithm = "histogram",
    timeout = 2500,
    silent = false,
    after_exit = function() end,
  })
  local cmd = opts.cmd
  if not vim.islist(cmd) then
    vim.notify("Invalid 'cmd': expected a list of strings", vim.log.levels.ERROR)
    return
  end
  local stdin1 = opts.stdin[1] or 1
  local stdin2 = opts.stdin[2] or vim.api.nvim_buf_line_count(buf) + 1
  local range1 = opts.range[1] or stdin1
  local range2 = opts.range[2] or stdin2
  local mode = vim.fn.mode()
  if vim.tbl_isempty(opts.range) and mode:match("[vV]") then
    local v1 = vim.api.nvim_win_get_cursor(0)[1]
    local v2 = vim.fn.getpos("v")[2]
    range1 = math.min(v1, v2)
    range2 = math.max(v1, v2) + 1
  end
  local lines = vim.api.nvim_buf_get_lines(buf, stdin1 - 1, stdin2 - 1, true)
  local file = vim.api.nvim_buf_get_name(buf)
  ---@param out vim.SystemCompleted
  local on_exit = vim.schedule_wrap(function(out)
    if out.code == 0 then
      local fmt = assert(out.stdout, "No stdout")
      local fmt_lines = opts.transform(fmt)
      if opts.diff == "none" then
        vim.api.nvim_buf_set_lines(buf, stdin1 - 1, stdin2 - 1, true, fmt_lines)
        return
      end
      local lines_str = table.concat(lines, "\n") .. "\n"
      local diff_opts = { result_type = "indices", algorithm = opts.diff_algorithm }
      local diff = vim.text.diff(lines_str, fmt, diff_opts)
      if not diff then
        return
      end
      for i = #diff, 1, -1 do
        local d = diff[i]
        local a = { d[1], d[1] + d[2] }
        local b = { d[3], d[3] + d[4] }
        local a_buf = { a[1] + stdin1 - 1, a[2] + stdin1 - 1 }
        local set_hunk = function()
          local repl = b[1] == b[2] and {} or vim.list_slice(fmt_lines, b[1], b[2] - 1)
          local offs = a[1] == a[2] and 0 or -1
          vim.api.nvim_buf_set_lines(buf, a_buf[1] + offs, a_buf[2] + offs, false, repl)
        end
        if opts.diff == "any" then
          set_hunk()
        end
        if opts.diff == "contain" then
          if range1 <= a_buf[1] and range2 >= a_buf[2] then
            set_hunk()
          end
        end
        if opts.diff == "overlap" then
          if range1 <= a_buf[2] and a_buf[1] <= range2 then
            set_hunk()
          end
        end
      end
    else
      if not opts.silent then
        vim.notify(string.format("-%s- %s", cmd[1], out.stderr), vim.log.levels.ERROR)
      end
    end
    opts.after_exit(out)
  end)
  local sysopts = { ---@type vim.SystemOpts
    stdin = lines,
    text = true,
    cwd = vim.fs.dirname(file),
    timeout = opts.timeout,
  }
  return vim.system(cmd, sysopts, on_exit)
end

---@class FormatOpts
---@field range? [integer,integer]
---@field async? boolean
---@field or_lsp? boolean
---@field silent? boolean

---@param local_opts? FormatOpts
local format = function(local_opts)
  local_opts = vim.tbl_extend("keep", local_opts or {}, {
    range = {},
    async = false,
    or_lsp = true,
    silent = false,
  })
  local range = local_opts.range
  local formatconf = vim.g.formatconf or {}
  local conf = formatconf[vim.bo.ft]
  if not vim.is_callable(conf) then
    if local_opts.or_lsp then
      local lsp_range = { ["start"] = { range[1], 0 }, ["end"] = { range[2] - 1, -1 } }
      vim.lsp.buf.format({
        range = vim.tbl_isempty(range) and nil or lsp_range,
        async = local_opts.async,
      })
    end
    return false
  end
  local line1 = range[1] or 1
  local line2 = range[2] or vim.api.nvim_buf_line_count(0) + 1
  local mode = vim.fn.mode()
  if vim.tbl_isempty(range) and mode:match("[vV]") then
    local v1 = vim.api.nvim_win_get_cursor(0)[1]
    local v2 = vim.fn.getpos("v")[2]
    line1 = math.min(v1, v2)
    line2 = math.max(v1, v2) + 1
  end
  ---@return vim.SystemCompleted
  local format_co = function(buf, opts)
    opts = vim.tbl_extend("keep", opts or {}, {
      range = { line1, line2 },
      silent = local_opts.silent,
    })
    if local_opts.async then
      local co = coroutine.running()
      local after_exit = opts.after_exit
      opts.after_exit = function(out)
        if type(after_exit) == "function" then
          after_exit(out)
        end
        coroutine.resume(co, out)
      end
      format_buf(buf, opts)
      return coroutine.yield()
    else
      return format_buf(buf, opts):wait()
    end
  end
  local co = coroutine.create(function()
    local fmt_opts = conf(line1, line2)
    fmt_opts = vim.islist(fmt_opts) and fmt_opts or { fmt_opts }
    for _, opts in ipairs(fmt_opts) do
      local out = format_co(0, opts)
      if out.code ~= 0 then
        break
      end
    end
  end)
  coroutine.resume(co)
  return co
end

_G.Formatexpr = function()
  format({ range = { vim.v.lnum, vim.v.lnum + vim.v.count } })
end

vim.o.formatexpr = "v:lua.Formatexpr()"
vim.keymap.set("n", "gqag", function()
  format()
end)
vim.keymap.set("n", "gqga", function()
  format()
end)

vim.api.nvim_create_user_command("Format", function()
  format()
end, {})

vim.cmd.cnoreabbrev("A", "AutoformatToggle")
vim.api.nvim_create_user_command("AutoformatToggle", function()
  vim.g.format_on_save = not vim.g.format_on_save
  vim.notify(string.format("Autoformat: %s", vim.g.format_on_save))
end, {})

vim.api.nvim_create_autocmd("BufWritePre", {
  group = vim.api.nvim_create_augroup("format_on_save", { clear = true }),
  callback = function()
    local if_unset = false
    local is_enabled = vim.F.if_nil({ vim.b.format_on_save, vim.g.format_on_save, if_unset })
    if is_enabled then
      format({ async = true, silent = true })
    end
  end,
})

-- -- Terminal

vim.api.nvim_create_autocmd("TermOpen", {
  desc = "Set options for the terminal window",
  group = vim.api.nvim_create_augroup("term_open", { clear = true }),
  callback = function()
    vim.wo.number = false
    vim.wo.relativenumber = false
  end,
})

vim.keymap.set("t", "<Esc><Esc>", "<C-\\><C-n>", { desc = "Exit terminal mode" })

vim.cmd.cnoreabbrev("lz", "Lazygit")
vim.cmd.cnoreabbrev("Lz", "Lazygit")
vim.api.nvim_create_user_command("Lazygit", function()
  vim.cmd.tabnew()
  vim.cmd.terminal("lazygit")
  local win = vim.api.nvim_get_current_win()
  vim.api.nvim_create_autocmd("WinClosed", {
    pattern = tostring(win),
    once = true,
    callback = function(e)
      vim.cmd.bwipeout({ args = { e.buf }, bang = true })
    end,
  })
  pcall(vim.cmd.file, "term:lazygit")
  vim.cmd.startinsert()
end, {})

-- -- -- Count terminal

_G.Terminal = {
  store = {},
  openinsert = true,
}
function Terminal.close(id, unload)
  local term = Terminal.store[id]
  if not term then
    return nil
  end
  local count = nil
  if vim.api.nvim_win_is_valid(term.win) then
    local buf = vim.api.nvim_win_get_buf(term.win)
    count = vim.b[buf].term_count
    _G.Terminal.openinsert = vim.fn.mode() == "t"
    vim.api.nvim_win_close(term.win, unload)
    term.win = -1
  end
  if unload then
    for _, buf in ipairs(term.buflist) do
      vim.api.nvim_buf_delete(buf, { force = true })
    end
    Terminal.store[id] = nil
  end
  return count
end
function Terminal.open(id, count, win_config)
  count = count or 1
  win_config = win_config or {}
  Terminal.store[id] = Terminal.store[id] or {
    win = -1,
    buflist = {},
  }
  local term = Terminal.store[id]
  local mods = { mods = { split = "botright" } }
  local new = function(buf, win_conf)
    buf = buf or -1
    win_conf = win_conf or {}
    local is_buf = vim.api.nvim_buf_is_valid(buf)
    if is_buf then
      vim.cmd.split(mods)
    else
      vim.cmd.terminal(mods)
      buf = vim.api.nvim_get_current_buf()
    end
    local win = vim.api.nvim_get_current_win()
    term.win = win
    vim.api.nvim_win_set_config(win, win_conf)
    if is_buf then
      vim.wo[win].winfixbuf = false
      vim.api.nvim_win_set_buf(win, buf)
    end
    vim.wo[win].winfixbuf = true
    term.buflist[count] = buf
    vim.b[buf].term_count = count
    if _G.Terminal.openinsert then
      vim.api.nvim_win_call(term.win, vim.cmd.startinsert)
    end
  end
  if vim.api.nvim_win_is_valid(term.win) then
    local buf = term.buflist[count] or -1
    if vim.api.nvim_buf_is_valid(buf) then
      vim.api.nvim_win_set_config(0, win_config)
      vim.wo[term.win].winfixbuf = false
      vim.api.nvim_win_set_buf(term.win, buf)
      vim.wo[term.win].winfixbuf = true
    else
      local win_state = vim.api.nvim_win_get_config(term.win)
      vim.api.nvim_win_close(term.win, false)
      new(nil, win_state)
    end
  else
    local buf = term.buflist[count] or -1
    new(buf, win_config)
  end
  return term.win
end
do
  local last_count = 1 ---@type integer?
  local win = -1
  local win_config = { height = 15 } ---@type vim.api.keyset.win_config
  local open_term = function(count)
    win = Terminal.open("default", count, win_config)
    vim.wo[win].winbar = "Terminal " .. count
  end
  vim.keymap.set({ "v", "n", "t" }, "<M-`>", function()
    if vim.api.nvim_win_is_valid(win) then
      local conf = vim.api.nvim_win_get_config(win)
      local is_vert = vim.list_contains({ "above", "below" }, conf.split)
      win_config.height = is_vert and conf.height or 15
      win_config.split = "below"
      if vim.v.count == 0 then
        last_count = Terminal.close("default", false)
      else
        open_term(vim.v.count1)
      end
    else
      open_term(vim.v.count == 0 and last_count or vim.v.count1)
    end
  end, { desc = "Terminal" })
end

-- -- Marks

local mark_ns = vim.api.nvim_create_namespace("mark_virtual")
local marks_group = vim.api.nvim_create_augroup("mark_virtual", { clear = true })
vim.g.virt_marks = true
local get_marks = function(buf, filter)
  buf = buf or 0
  buf = buf == 0 and vim.api.nvim_get_current_buf() or buf
  local file = vim.api.nvim_buf_get_name(buf)
  filter = filter or function(m)
    return m.mark:match("'%a")
  end
  -- stylua: ignore
  local buffer_marks = vim.iter(vim.fn.getmarklist(buf))
    :map(function(m) m.type = "buffer"; return m end)
    :totable()
  -- stylua: ignore
  local global_marks = vim.iter(vim.fn.getmarklist())
    :filter(function(m) return vim.fn.fnamemodify(m.file, ":p") == file end)
    :map(function(m) m.type = "global"; return m end)
    :totable()
  return vim.iter({ buffer_marks, global_marks }):flatten(1):filter(filter):totable()
end
local clear_marks = function(buf)
  vim.api.nvim_buf_clear_namespace(buf, mark_ns, 0, -1)
end
local draw_marks = function(buf)
  clear_marks(buf)
  local buf_marks = get_marks(buf)
  local lnum_marks = {}
  for _, m in ipairs(buf_marks) do
    local _, lnum = unpack(m.pos)
    lnum = lnum - 1
    lnum_marks[lnum] = lnum_marks[lnum] or {}
    table.insert(lnum_marks[lnum], m)
  end
  local get_indent = function(lnum)
    local line = table.remove(vim.api.nvim_buf_get_lines(buf, lnum, lnum + 1, false))
    line = line or ""
    return string.match(line, "^%s+") or ""
  end
  local line_count = vim.api.nvim_buf_line_count(buf)
  for lnum, marks in pairs(lnum_marks) do
    if lnum < line_count then
      local indent = get_indent(lnum)
      local virt_lines = {}
      for _, m in ipairs(marks) do
        table.insert(virt_lines, { { string.format("%s %s", indent, m.mark), "Comment" } })
      end
      vim.api.nvim_buf_set_extmark(buf, mark_ns, lnum, 0, {
        virt_lines = virt_lines,
        virt_lines_above = true,
        strict = false,
      })
    end
  end
  return buf_marks
end
local apply_marks = function(buf, enabled)
  vim.g.virt_marks = true
  if enabled ~= nil then
    vim.b[buf].virt_marks = enabled
  end
  if vim.b[buf].virt_marks then
    draw_marks(buf)
  else
    clear_marks(buf)
  end
end
--
local toggle_marks = function(buf)
  buf = buf or 0
  apply_marks(buf, not vim.b[buf].virt_marks)
end
local toggle_marks_all = function()
  local next_val = not vim.b.virt_marks
  for _, buf in ipairs(vim.api.nvim_list_bufs()) do
    apply_marks(buf, next_val)
  end
end
-- stylua: ignore start
vim.keymap.set("n", "<Leader>m", function() toggle_marks() end, { desc = "Toggle buf marks" })
vim.keymap.set("n", "<Leader>M", function() toggle_marks_all() end, { desc = "Toggle marks" })
-- stylua: ignore end
vim.api.nvim_create_autocmd({ "BufEnter", "CursorHold" }, {
  desc = "Show named vim marks as virtual lines",
  group = marks_group,
  callback = function(e)
    local buf = e.buf
    if not vim.api.nvim_buf_is_loaded(buf) then
      return
    end
    if not vim.g.virt_marks then
      return
    end
    if vim.b[buf].virt_marks == nil then
      vim.b[buf].virt_marks = vim.g.virt_marks
    end
    apply_marks(buf)
  end,
})

-- -- Checkout (mini.git)

local conflict_ns = vim.api.nvim_create_namespace("git_conflict")
local conflict_au = vim.api.nvim_create_augroup("git_conflict", { clear = false })

-- get_buf_conflicts(buf) -> { { {1,5}, {3,5}, {5,7} }, ... }
--                               ours   base?  theirs
-- 1: <<<<<<< HEAD
-- 2: local a = "main"
-- 3: ||||||| parent of xxxxxxx (xxx)
-- 4: local a = "base"
-- 5: =======
-- 6: local a = "feature"
-- 7: >>>>>>> xxxxxxx (xxx)
--
local function find_conflicts(buf)
  buf = buf or 0
  local lines = vim.api.nvim_buf_get_lines(buf, 0, -1, true)
  local ours, base, theirs = {}, {}, {}
  local conflicts = {}
  local on_end_mark = function()
    local full = function(val)
      return val[1] and val[2]
    end
    if full(ours) and full(theirs) then
      base = full(base) and base or nil
      table.insert(conflicts, { ours, base, theirs })
      ours, base, theirs = {}, {}, {}
    end
  end
  -- stylua: ignore
  for ln, line in ipairs(lines) do
    if vim.startswith(line, "<<<<<<<") then ours[1] = ln end
    if vim.startswith(line, "|||||||") then base[1] = ln end
    if vim.startswith(line, "=======") then ours[2], base[2], theirs[1] = ln, ln, ln end
    if vim.startswith(line, ">>>>>>>") then theirs[2] = ln; on_end_mark() end
  end
  return conflicts
end

local conflict_state = {}
local function toggle_conflicts(buf)
  buf = buf or 0
  if not vim.api.nvim_buf_is_valid(buf) then
    vim.notify(string.format("Invalid buffer: %d", buf), vim.log.levels.ERROR)
    return
  end
  conflict_state[buf] = not conflict_state[buf]
  if not conflict_state[buf] then
    vim.api.nvim_clear_autocmds({ group = conflict_au, buffer = buf })
    vim.api.nvim_buf_clear_namespace(buf, conflict_ns, 0, -1)
    vim.b[buf].minigit_conflicts = nil
  else
    local update = function() ---@diagnostic disable-line: redefined-local
      local conflicts = find_conflicts(buf)
      vim.b[buf].minigit_conflicts = conflicts
      vim.api.nvim_buf_clear_namespace(buf, conflict_ns, 0, -1)
      local hi = function(from, to, hl)
        vim.api.nvim_buf_set_extmark(buf, conflict_ns, from - 1, 0, {
          end_row = to,
          hl_group = hl,
          hl_eol = true,
        })
      end
      for _, conflict in ipairs(conflicts) do
        local ours, base, theirs = unpack(conflict)
        hi(ours[1], ours[2] - 1, "DiffText")
        hi(theirs[1] + 1, theirs[2], "DiffAdd")
        if base then
          hi(base[1], base[2] - 1, "DiffDelete")
        end
      end
    end
    update()
    vim.api.nvim_clear_autocmds({ group = conflict_au, buffer = buf })
    vim.api.nvim_create_autocmd("ModeChanged", { pattern = "i:*", group = conflict_au, callback = update })
    vim.api.nvim_create_autocmd("TextChanged", { group = conflict_au, buffer = buf, callback = update })
  end
end

local conflict_acts = {}
do
  local get_conflict = function()
    local lnum = vim.api.nvim_win_get_cursor(0)[1]
    for _, conflict in ipairs(vim.b.minigit_conflicts or {}) do
      local ours, _, theirs = unpack(conflict)
      if lnum >= ours[1] and lnum <= theirs[2] then
        return conflict
      end
    end
  end
  local replace_conflict = function(conflict, lines)
    local ours, _, theirs = unpack(conflict)
    vim.api.nvim_buf_set_lines(0, ours[1] - 1, theirs[2], true, lines)
    vim.api.nvim_win_set_cursor(0, { ours[1], 0 })
  end
  local get_lines = function(from, to)
    return vim.api.nvim_buf_get_lines(0, from - 1, to - 1, true)
  end
  local search = function(line, pattern, ...)
    line = type(line) == "number" and line or vim.fn.line(line)
    local saved_pos = vim.fn.getpos(".")
    vim.fn.cursor(line, 0)
    if vim.fn.search(pattern, ...) == 0 or vim.fn.line(".") == saved_pos[2] then
      vim.fn.cursor(saved_pos[2], saved_pos[3])
    end
  end
  --
  conflict_acts.ours = function()
    local conflict = get_conflict()
    if conflict then
      local ours, base, _ = unpack(conflict)
      local repl = get_lines(ours[1] + 1, base[1] or ours[2])
      replace_conflict(conflict, repl)
    end
  end
  conflict_acts.theirs = function()
    local conflict = get_conflict()
    if conflict then
      local _, _, theirs = unpack(conflict)
      local repl = get_lines(theirs[1] + 1, theirs[2])
      replace_conflict(conflict, repl)
    end
  end
  conflict_acts.both = function()
    local conflict = get_conflict()
    if conflict then
      local ours, base, theirs = unpack(conflict)
      local repl = {}
      vim.list_extend(repl, get_lines(ours[1] + 1, base[1] or ours[2]))
      vim.list_extend(repl, get_lines(theirs[1] + 1, theirs[2]))
      replace_conflict(conflict, repl)
    end
  end
  conflict_acts.none = function()
    local conflict = get_conflict()
    if conflict then
      replace_conflict(conflict, {})
    end
  end
  conflict_acts.forward = function()
    for _ = 1, vim.v.count1 do
      search(".", "^<<<<<<< ")
    end
  end
  conflict_acts.backward = function()
    for _ = 1, vim.v.count1 do
      search(".", "^<<<<<<< ", "b")
    end
  end
  conflict_acts.last = function()
    search("$", "^<<<<<<< ", "bW")
  end
  conflict_acts.first = function()
    search(1, "^<<<<<<< ", "cW")
  end
end

local function minigit_is_merge(buf)
  buf = buf or 0
  local git_summary = vim.b[buf].minigit_summary or {}
  local in_progress = git_summary.in_progress
  return in_progress and (in_progress:find("merge") or in_progress:find("rebase"))
end

vim.api.nvim_create_autocmd("User", {
  pattern = "MiniGitUpdated",
  group = conflict_au,
  callback = function(e)
    local buf = e.buf
    if minigit_is_merge(buf) then
      if not vim.b[buf].minigit_conflicts then
        toggle_conflicts(buf)
        vim.keymap.set("n", "co", conflict_acts.ours, { buffer = buf, desc = "Checkout ours" })
        vim.keymap.set("n", "ct", conflict_acts.theirs, { buffer = buf, desc = "Checkout theirs" })
        vim.keymap.set("n", "cb", conflict_acts.both, { buffer = buf, desc = "Checkout both" })
        vim.keymap.set("n", "c0", conflict_acts.none, { buffer = buf, desc = "Checkout none" })
        vim.keymap.set("n", "]x", conflict_acts.forward, { buffer = buf, desc = "Conflict forward" })
        vim.keymap.set("n", "[x", conflict_acts.backward, { buffer = buf, desc = "Conflict backward" })
        vim.keymap.set("n", "]X", conflict_acts.last, { buffer = buf, desc = "Conflict last" })
        vim.keymap.set("n", "[X", conflict_acts.first, { buffer = buf, desc = "Conflict first" })
      end
    else
      if vim.b[buf].minigit_conflicts then
        toggle_conflicts(buf)
        vim.keymap.del("n", "co", { buffer = buf })
        vim.keymap.del("n", "ct", { buffer = buf })
        vim.keymap.del("n", "cb", { buffer = buf })
        vim.keymap.del("n", "c0", { buffer = buf })
        vim.keymap.del("n", "]x", { buffer = buf })
        vim.keymap.del("n", "[x", { buffer = buf })
        vim.keymap.del("n", "]X", { buffer = buf })
        vim.keymap.del("n", "[X", { buffer = buf })
      end
    end
  end,
})
